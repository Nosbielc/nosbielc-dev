---
title: "Command Pattern em Java e Kotlin: Um Guia Completo"
description: "Aprenda como implementar o Command Pattern em Java e Kotlin com exemplos pr√°ticos e compreenda os benef√≠cios desse poderoso padr√£o de design."
date: May 28 2024
---

## Introdu√ß√£o

O Command Pattern √© um padr√£o de design comportamental que transforma solicita√ß√µes em objetos aut√¥nomos que cont√™m todas as informa√ß√µes necess√°rias para executar a a√ß√£o. Esse padr√£o √© particularmente √∫til para enfileirar, registrar e desfazer opera√ß√µes. Neste post, exploraremos o Command Pattern em profundidade, fornecendo exemplos em Java e Kotlin.

## O que √© o Command Pattern?

O Command Pattern encapsula uma solicita√ß√£o como um objeto, permitindo parametrizar clientes com diferentes solicita√ß√µes, enfileirar ou registrar solicita√ß√µes e suportar opera√ß√µes revers√≠veis.

## Estrutura do Command Pattern

A estrutura b√°sica do Command Pattern envolve os seguintes componentes:
- **Command**: Declara uma interface para executar uma opera√ß√£o.
- **ConcreteCommand**: Implementa a interface Command, ligando uma a√ß√£o ao Receiver.
- **Receiver**: Sabe como executar as opera√ß√µes associadas √† a√ß√£o.
- **Invoker**: Pede ao Command para executar a solicita√ß√£o.
- **Client**: Cria um objeto ConcreteCommand e define seu Receiver.

## Exemplo em Java

Aqui est√° um exemplo de implementa√ß√£o do Command Pattern em Java:

```java
    // Command Interface
    public interface Command {
        void execute();
    }

    // Concrete Command
    public class LightOnCommand implements Command {
        private Light light;

        public LightOnCommand(Light light) {
            this.light = light;
        }

        @Override
        public void execute() {
            light.on();
        }
    }

    // Receiver
    public class Light {
        public void on() {
            System.out.println("The light is on");
        }

        public void off() {
            System.out.println("The light is off");
        }
    }

    // Invoker
    public class RemoteControl {
        private Command command;

        public void setCommand(Command command) {
            this.command = command;
        }

        public void pressButton() {
            command.execute();
        }
    }

    // Client
    public class Client {
        public static void main(String[] args) {
            Light light = new Light();
            Command lightOn = new LightOnCommand(light);

            RemoteControl remote = new RemoteControl();
            remote.setCommand(lightOn);
            remote.pressButton();
        }
    }
```

Neste exemplo, criamos uma interface \`Command\` com um m√©todo \`execute()\`. A classe \`LightOnCommand\` implementa esta interface e define a a√ß√£o de ligar a luz. A classe \`Light\` atua como o Receiver que sabe como executar as a√ß√µes. A classe \`RemoteControl\` √© o Invoker que chama o comando. Finalmente, a classe \`Client\` cria e configura os objetos.

## Exemplo em Kotlin

Aqui est√° o mesmo exemplo implementado em Kotlin:

```java
    // Command Interface
    interface Command {
        fun execute()
    }

    // Concrete Command
    class LightOnCommand(private val light: Light) : Command {
        override fun execute() {
            light.on()
        }
    }

    // Receiver
    class Light {
        fun on() {
            println("The light is on")
        }

        fun off() {
            println("The light is off")
        }
    }

    // Invoker
    class RemoteControl {
        private var command: Command? = null

        fun setCommand(command: Command) {
            this.command = command
        }

        fun pressButton() {
            command?.execute()
        }
    }

    // Client
    fun main() {
        val light = Light()
        val lightOnCommand = LightOnCommand(light)

        val remote = RemoteControl()
        remote.setCommand(lightOnCommand)
        remote.pressButton()
    }
```

No exemplo em Kotlin, a estrutura √© similar √† do Java, mas a sintaxe √© mais concisa. A interface \`Command\` √© implementada pela classe \`LightOnCommand\`, que define a a√ß√£o de ligar a luz. A classe \`Light\` √© o Receiver, e a classe \`RemoteControl\` √© o Invoker. O cliente cria e configura os objetos necess√°rios.

## Benef√≠cios do Command Pattern

- **Desacoplamento**: O Command Pattern desacopla o objeto que invoca a opera√ß√£o do objeto que conhece como execut√°-la.
- **Flexibilidade**: Permite criar comandos din√¢micos e complexos.
- **Undo/Redo**: Facilita a implementa√ß√£o de funcionalidades de desfazer e refazer.

## Conclus√£o

O Command Pattern √© uma poderosa ferramenta para a cria√ß√£o de sistemas flex√≠veis e extens√≠veis. Com este padr√£o, voc√™ pode encapsular a√ß√µes como objetos, tornando mais f√°cil enfileirar, registrar e desfazer opera√ß√µes. Esperamos que este guia tenha ajudado voc√™ a entender como implementar o Command Pattern em Java e Kotlin.

Para mais conte√∫dos sobre padr√µes de design e desenvolvimento de software, continue acompanhando nosso blog!

---

Refer√™ncias:
- Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley.
---

**üîó Reposit√≥rio de Exemplos**

Aqui o link para nosso laborat√≥rio: [https://github.com/Nosbielc/nosbielc-dev-demos](https://github.com/Nosbielc/nosbielc-dev-demos)