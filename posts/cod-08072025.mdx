---
title: "Flyweight Pattern em Java: Otimizando Mem√≥ria com Compartilhamento de Objetos"
description: "Aprenda como implementar o Flyweight Pattern em Java para otimizar o uso de mem√≥ria atrav√©s do compartilhamento eficiente de objetos similares. Descubra como este padr√£o estrutural pode melhorar a performance de aplica√ß√µes."
date: Jul 08 2025
---

## Introdu√ß√£o

O **Flyweight Pattern** (Padr√£o Peso-Leve) √© um padr√£o de design estrutural que minimiza o uso de mem√≥ria compartilhando eficientemente objetos similares. Este padr√£o √© particularmente √∫til quando voc√™ precisa criar um grande n√∫mero de objetos similares, onde a maioria dos dados pode ser compartilhada.

Neste post, exploraremos o conceito do Flyweight Pattern, suas vantagens e como implement√°-lo em Java com exemplos pr√°ticos que demonstram a economia de mem√≥ria.

---

## O que √© o Flyweight Pattern?

O Flyweight Pattern resolve o problema de consumo excessivo de mem√≥ria quando voc√™ precisa criar muitos objetos similares. Em vez de armazenar todos os dados em cada objeto, o padr√£o separa os dados em duas categorias:

- **Estado Intr√≠nseco:** Dados que podem ser compartilhados entre m√∫ltiplos objetos
- **Estado Extr√≠nseco:** Dados √∫nicos para cada objeto, passados como par√¢metros

**Principais componentes:**

1. **Flyweight:** Interface que define m√©todos atrav√©s dos quais os flyweights podem receber e atuar sobre estados extr√≠nsecos.
2. **ConcreteFlyweight:** Implementa a interface Flyweight e adiciona armazenamento para estado intr√≠nseco.
3. **UnsharedConcreteFlyweight:** N√£o compartilha estado e armazena todo o estado necess√°rio.
4. **FlyweightFactory:** Cria e gerencia objetos flyweight, garantindo que sejam compartilhados adequadamente.
5. **Context:** Mant√©m refer√™ncias a flyweights e armazena estados extr√≠nsecos.

---

## Quando usar o Flyweight Pattern?

- Quando sua aplica√ß√£o precisa gerar um grande n√∫mero de objetos similares.
- Quando o custo de armazenamento √© alto devido √† grande quantidade de objetos.
- Quando grupos de objetos podem ser substitu√≠dos por poucos objetos compartilhados.
- Quando o estado extr√≠nseco pode ser facilmente separado do estado intr√≠nseco.
- Quando voc√™ quer reduzir o uso de mem√≥ria sem afetar a funcionalidade.

---

## Exemplo Pr√°tico em Java

Vamos implementar um sistema de renderiza√ß√£o de caracteres para um editor de texto, onde cada caractere tem propriedades como fonte, tamanho e cor que podem ser compartilhadas.

---

#### 1. Definindo a Interface Flyweight

A interface define o contrato para todos os flyweights:

```java
public interface CharacterFlyweight {
    void render(int x, int y, String color);
}
```

#### 2. Implementando o Flyweight Concreto

Esta classe armazena o estado intr√≠nseco (fonte e tamanho):

```java
public class ConcreteCharacter implements CharacterFlyweight {
    private final char character;
    private final String font;
    private final int size;
    
    public ConcreteCharacter(char character, String font, int size) {
        this.character = character;
        this.font = font;
        this.size = size;
    }
    
    @Override
    public void render(int x, int y, String color) {
        System.out.println("Renderizando caractere '" + character + "' em (" + x + "," + y + 
                         ") com fonte " + font + ", tamanho " + size + " e cor " + color);
    }
    
    public char getCharacter() {
        return character;
    }
    
    public String getFont() {
        return font;
    }
    
    public int getSize() {
        return size;
    }
}
```

#### 3. Criando a Factory

A factory garante que flyweights sejam compartilhados:

```java
import java.util.HashMap;
import java.util.Map;

public class CharacterFlyweightFactory {
    private static final Map<String, CharacterFlyweight> flyweights = new HashMap<>();
    
    public static CharacterFlyweight getFlyweight(char character, String font, int size) {
        String key = character + font + size;
        
        CharacterFlyweight flyweight = flyweights.get(key);
        if (flyweight == null) {
            flyweight = new ConcreteCharacter(character, font, size);
            flyweights.put(key, flyweight);
            System.out.println("Criando novo flyweight para: " + key);
        }
        return flyweight;
    }
    
    public static int getCreatedFlyweightsCount() {
        return flyweights.size();
    }
    
    public static void printFlyweights() {
        System.out.println("Flyweights criados: " + flyweights.size());
        for (Map.Entry<String, CharacterFlyweight> entry : flyweights.entrySet()) {
            System.out.println("- " + entry.getKey());
        }
    }
}
```

#### 4. Implementando o Context

O contexto mant√©m o estado extr√≠nseco:

```java
public class CharacterContext {
    private final CharacterFlyweight flyweight;
    private final int x;
    private final int y;
    private final String color;
    
    public CharacterContext(char character, String font, int size, int x, int y, String color) {
        this.flyweight = CharacterFlyweightFactory.getFlyweight(character, font, size);
        this.x = x;
        this.y = y;
        this.color = color;
    }
    
    public void render() {
        flyweight.render(x, y, color);
    }
}
```

#### 5. Criando o Cliente

Exemplo de uso do padr√£o:

```java
import java.util.ArrayList;
import java.util.List;

public class TextEditor {
    private List<CharacterContext> characters = new ArrayList<>();
    
    public void addCharacter(char character, String font, int size, int x, int y, String color) {
        CharacterContext context = new CharacterContext(character, font, size, x, y, color);
        characters.add(context);
    }
    
    public void render() {
        System.out.println("Renderizando texto:");
        for (CharacterContext context : characters) {
            context.render();
        }
    }
    
    public static void main(String[] args) {
        TextEditor editor = new TextEditor();
        
        // Adicionando caracteres com propriedades similares
        editor.addCharacter('H', "Arial", 12, 0, 0, "preto");
        editor.addCharacter('e', "Arial", 12, 10, 0, "preto");
        editor.addCharacter('l', "Arial", 12, 20, 0, "preto");
        editor.addCharacter('l', "Arial", 12, 30, 0, "preto");
        editor.addCharacter('o', "Arial", 12, 40, 0, "preto");
        editor.addCharacter(' ', "Arial", 12, 50, 0, "preto");
        editor.addCharacter('W', "Arial", 12, 60, 0, "azul");
        editor.addCharacter('o', "Arial", 12, 70, 0, "azul");
        editor.addCharacter('r', "Arial", 12, 80, 0, "azul");
        editor.addCharacter('l', "Arial", 12, 90, 0, "azul");
        editor.addCharacter('d', "Arial", 12, 100, 0, "azul");
        
        // Renderizando o texto
        editor.render();
        
        System.out.println("\n--- Estat√≠sticas ---");
        System.out.println("Caracteres totais: " + editor.characters.size());
        CharacterFlyweightFactory.printFlyweights();
    }
}
```

### Sa√≠da do Programa

```
Criando novo flyweight para: HArial12
Criando novo flyweight para: eArial12
Criando novo flyweight para: lArial12
Criando novo flyweight para: oArial12
Criando novo flyweight para:  Arial12
Criando novo flyweight para: WArial12
Criando novo flyweight para: rArial12
Criando novo flyweight para: dArial12

Renderizando texto:
Renderizando caractere 'H' em (0,0) com fonte Arial, tamanho 12 e cor preto
Renderizando caractere 'e' em (10,0) com fonte Arial, tamanho 12 e cor preto
Renderizando caractere 'l' em (20,0) com fonte Arial, tamanho 12 e cor preto
Renderizando caractere 'l' em (30,0) com fonte Arial, tamanho 12 e cor preto
Renderizando caractere 'o' em (40,0) com fonte Arial, tamanho 12 e cor preto
Renderizando caractere ' ' em (50,0) com fonte Arial, tamanho 12 e cor preto
Renderizando caractere 'W' em (60,0) com fonte Arial, tamanho 12 e cor azul
Renderizando caractere 'o' em (70,0) com fonte Arial, tamanho 12 e cor azul
Renderizando caractere 'r' em (80,0) com fonte Arial, tamanho 12 e cor azul
Renderizando caractere 'l' em (90,0) com fonte Arial, tamanho 12 e cor azul
Renderizando caractere 'd' em (100,0) com fonte Arial, tamanho 12 e cor azul

--- Estat√≠sticas ---
Caracteres totais: 11
Flyweights criados: 8
- HArial12
- eArial12
- lArial12
- oArial12
-  Arial12
- WArial12
- rArial12
- dArial12
```

### Explica√ß√£o do C√≥digo

1. **Separa√ß√£o de Estados:** O estado intr√≠nseco (caractere, fonte, tamanho) √© compartilhado, enquanto o estado extr√≠nseco (posi√ß√£o, cor) √© passado como par√¢metro.

2. **Compartilhamento:** Caracteres repetidos (como 'l' e 'o') reutilizam o mesmo flyweight, economizando mem√≥ria.

3. **Factory:** Controla a cria√ß√£o e reutiliza√ß√£o dos flyweights, garantindo que objetos similares sejam compartilhados.

4. **Context:** Mant√©m as informa√ß√µes espec√≠ficas de cada inst√¢ncia sem duplicar o estado intr√≠nseco.

---

## Vantagens e Desvantagens

### Vantagens

- **Economia de Mem√≥ria:** Reduz drasticamente o consumo de mem√≥ria quando voc√™ tem muitos objetos similares.
- **Performance:** Menos objetos significam menos garbage collection e melhor performance.
- **Compartilhamento:** Objetos s√£o reutilizados eficientemente.
- **Transpar√™ncia:** O cliente n√£o precisa se preocupar com a otimiza√ß√£o de mem√≥ria.

### Desvantagens

- **Complexidade:** Adiciona complexidade ao c√≥digo, especialmente na separa√ß√£o de estados.
- **Overhead de Computa√ß√£o:** Pode haver overhead computacional ao calcular estados extr√≠nsecos.
- **Troca de Tempo por Espa√ßo:** Economiza mem√≥ria mas pode aumentar o tempo de processamento.
- **Sincroniza√ß√£o:** Em ambientes multi-thread, pode ser necess√°rio sincronizar o acesso √† factory.

---

## Quando evitar o Flyweight Pattern?

- Quando voc√™ tem poucos objetos similares - o overhead pode n√£o compensar.
- Se os objetos n√£o compartilham estado suficiente para justificar a complexidade.
- Quando o estado extr√≠nseco √© muito complexo ou dif√≠cil de separar.
- Para aplica√ß√µes simples onde o uso de mem√≥ria n√£o √© uma preocupa√ß√£o.
- Quando a performance de acesso aos dados √© mais cr√≠tica que o uso de mem√≥ria.

---

## Conclus√£o

O Flyweight Pattern √© uma solu√ß√£o elegante para otimizar o uso de mem√≥ria em aplica√ß√µes que precisam criar muitos objetos similares. Embora adicione complexidade ao c√≥digo, os benef√≠cios de economia de mem√≥ria e melhoria de performance podem ser significativos em cen√°rios apropriados.

A chave para o sucesso na implementa√ß√£o do Flyweight Pattern est√° em identificar corretamente quais dados podem ser compartilhados (estado intr√≠nseco) e quais devem ser √∫nicos para cada inst√¢ncia (estado extr√≠nseco).

---

Gostou deste post? Continue acompanhando para mais conte√∫dos sobre padr√µes de design e otimiza√ß√£o em **Java**!
---

**üîó Reposit√≥rio de Exemplos**

Aqui o link para nosso laborat√≥rio: [https://github.com/Nosbielc/nosbielc-dev-demos](https://github.com/Nosbielc/nosbielc-dev-demos)