---
title: "Composite Pattern em Java: Estruturas Hier√°rquicas com Tratamento Uniforme"
description: "Aprenda como implementar o Composite Pattern em Java para criar estruturas hier√°rquicas complexas tratando objetos individuais e composi√ß√µes de forma uniforme. Descubra como este padr√£o estrutural pode simplificar o design de sistemas com hierarquias parte-todo."
date: Jul 03 2025
---

## Introdu√ß√£o

O **Composite Pattern** (Padr√£o Composto) √© um padr√£o de design estrutural que permite compor objetos em estruturas de √°rvore para representar hierarquias parte-todo. Este padr√£o permite que os clientes tratem objetos individuais e composi√ß√µes de objetos de maneira uniforme, simplificando significativamente o c√≥digo que trabalha com estruturas hier√°rquicas complexas.

Neste post, exploraremos o conceito do Composite Pattern, suas vantagens e como implement√°-lo em Java com exemplos pr√°ticos de um sistema de arquivos e componentes gr√°ficos.

---

## O que √© o Composite Pattern?

O Composite Pattern resolve o problema de trabalhar com estruturas hier√°rquicas onde voc√™ precisa tratar objetos individuais (folhas) e grupos de objetos (composi√ß√µes) da mesma forma. Em vez de ter c√≥digo espec√≠fico para cada tipo, o padr√£o permite que voc√™ trate tudo atrav√©s de uma interface comum.

**Principais componentes:**

1. **Component (Componente):** Interface ou classe abstrata que define opera√ß√µes comuns para objetos simples e compostos.
2. **Leaf (Folha):** Representa objetos finais na hierarquia que n√£o t√™m filhos.
3. **Composite (Composto):** Classe que pode conter componentes filhos e implementa opera√ß√µes relacionadas aos filhos.
4. **Client (Cliente):** Manipula objetos na composi√ß√£o atrav√©s da interface Component.

---

## Quando usar o Composite Pattern?

- Quando voc√™ precisa representar hierarquias parte-todo de objetos.
- Para tratar objetos individuais e composi√ß√µes de objetos de forma uniforme.
- Quando voc√™ quer que os clientes ignorem a diferen√ßa entre composi√ß√µes de objetos e objetos individuais.
- Para estruturas recursivas como √°rvores de diret√≥rios, menus, componentes gr√°ficos ou organiza√ß√µes empresariais.
- Quando voc√™ precisa aplicar opera√ß√µes em toda uma estrutura hier√°rquica.

---

## Exemplo Pr√°tico em Java

Vamos implementar um sistema de arquivos simples onde tanto arquivos quanto diret√≥rios podem ser tratados de forma uniforme:

### 1. Criando a Interface Component

A interface `FileSystemComponent` define as opera√ß√µes comuns:

```java
public interface FileSystemComponent {
    String getName();
    long getSize();
    void display(String prefix);
    
    // Opera√ß√µes para compostos (implementa√ß√£o padr√£o para folhas)
    default void add(FileSystemComponent component) {
        throw new UnsupportedOperationException("Opera√ß√£o n√£o suportada");
    }
    
    default void remove(FileSystemComponent component) {
        throw new UnsupportedOperationException("Opera√ß√£o n√£o suportada");
    }
    
    default List<FileSystemComponent> getChildren() {
        return Collections.emptyList();
    }
}
```

### 2. Implementando a Leaf (Arquivo)

A classe `File` representa um arquivo individual:

```java
public class File implements FileSystemComponent {
    private String name;
    private long size;
    
    public File(String name, long size) {
        this.name = name;
        this.size = size;
    }
    
    @Override
    public String getName() {
        return name;
    }
    
    @Override
    public long getSize() {
        return size;
    }
    
    @Override
    public void display(String prefix) {
        System.out.println(prefix + "üìÑ " + name + " (" + size + " bytes)");
    }
}
```

### 3. Implementando o Composite (Diret√≥rio)

A classe `Directory` pode conter outros componentes:

```java
import java.util.*;

public class Directory implements FileSystemComponent {
    private String name;
    private List<FileSystemComponent> children;
    
    public Directory(String name) {
        this.name = name;
        this.children = new ArrayList<>();
    }
    
    @Override
    public String getName() {
        return name;
    }
    
    @Override
    public long getSize() {
        return children.stream()
                      .mapToLong(FileSystemComponent::getSize)
                      .sum();
    }
    
    @Override
    public void display(String prefix) {
        System.out.println(prefix + "üìÅ " + name + "/ (" + getSize() + " bytes)");
        String childPrefix = prefix + "  ";
        
        for (FileSystemComponent child : children) {
            child.display(childPrefix);
        }
    }
    
    @Override
    public void add(FileSystemComponent component) {
        children.add(component);
    }
    
    @Override
    public void remove(FileSystemComponent component) {
        children.remove(component);
    }
    
    @Override
    public List<FileSystemComponent> getChildren() {
        return new ArrayList<>(children);
    }
}
```

### 4. Exemplo de Uso

```java
public class FileSystemExample {
    public static void main(String[] args) {
        // Criando arquivos
        FileSystemComponent arquivo1 = new File("documento.txt", 1024);
        FileSystemComponent arquivo2 = new File("imagem.jpg", 2048);
        FileSystemComponent arquivo3 = new File("README.md", 512);
        
        // Criando diret√≥rios
        Directory diretorioRaiz = new Directory("projeto");
        Directory diretorioSrc = new Directory("src");
        Directory diretorioDocs = new Directory("docs");
        
        // Construindo a hierarquia
        diretorioSrc.add(new File("Main.java", 1536));
        diretorioSrc.add(new File("Utils.java", 768));
        
        diretorioDocs.add(arquivo3);
        diretorioDocs.add(new File("manual.pdf", 4096));
        
        diretorioRaiz.add(arquivo1);
        diretorioRaiz.add(arquivo2);
        diretorioRaiz.add(diretorioSrc);
        diretorioRaiz.add(diretorioDocs);
        
        // Exibindo a estrutura
        System.out.println("Estrutura do Sistema de Arquivos:");
        diretorioRaiz.display("");
        
        System.out.println("\nTamanho total: " + diretorioRaiz.getSize() + " bytes");
        
        // Tratamento uniforme
        processarComponente(arquivo1);    // Arquivo individual
        processarComponente(diretorioRaiz); // Diret√≥rio completo
    }
    
    // M√©todo que trata tanto arquivos quanto diret√≥rios uniformemente
    public static void processarComponente(FileSystemComponent component) {
        System.out.println("Processando: " + component.getName() + 
                         " (Tamanho: " + component.getSize() + " bytes)");
    }
}
```

### Exemplo Avan√ßado: Sistema de Componentes Gr√°ficos

```java
// Interface para componentes gr√°ficos
public interface GraphicComponent {
    void render();
    void move(int x, int y);
    Rectangle getBounds();
}

// Componente simples (Leaf)
public class Shape implements GraphicComponent {
    private String type;
    private int x, y, width, height;
    
    public Shape(String type, int x, int y, int width, int height) {
        this.type = type;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    
    @Override
    public void render() {
        System.out.println("Renderizando " + type + " em (" + x + "," + y + ")");
    }
    
    @Override
    public void move(int deltaX, int deltaY) {
        this.x += deltaX;
        this.y += deltaY;
    }
    
    @Override
    public Rectangle getBounds() {
        return new Rectangle(x, y, width, height);
    }
}

// Componente composto
public class GraphicGroup implements GraphicComponent {
    private List<GraphicComponent> components = new ArrayList<>();
    private String name;
    
    public GraphicGroup(String name) {
        this.name = name;
    }
    
    public void add(GraphicComponent component) {
        components.add(component);
    }
    
    public void remove(GraphicComponent component) {
        components.remove(component);
    }
    
    @Override
    public void render() {
        System.out.println("Renderizando grupo: " + name);
        for (GraphicComponent component : components) {
            component.render();
        }
    }
    
    @Override
    public void move(int deltaX, int deltaY) {
        for (GraphicComponent component : components) {
            component.move(deltaX, deltaY);
        }
    }
    
    @Override
    public Rectangle getBounds() {
        if (components.isEmpty()) {
            return new Rectangle(0, 0, 0, 0);
        }
        
        Rectangle bounds = components.get(0).getBounds();
        for (int i = 1; i < components.size(); i++) {
            bounds = bounds.union(components.get(i).getBounds());
        }
        return bounds;
    }
}
```

---

## Vantagens do Composite Pattern

1. **Tratamento Uniforme:** Clientes podem tratar objetos individuais e composi√ß√µes da mesma forma.
2. **Flexibilidade:** Facilita a adi√ß√£o de novos tipos de componentes.
3. **Estruturas Complexas:** Permite criar estruturas hier√°rquicas arbitrariamente complexas.
4. **Recursividade Natural:** O padr√£o funciona naturalmente com estruturas recursivas.

---

## Quando evitar o Composite Pattern?

- Quando voc√™ n√£o tem estruturas hier√°rquicas ou parte-todo em seu sistema.
- Se a hierarquia √© muito simples e n√£o justifica a complexidade adicional.
- Quando o desempenho √© cr√≠tico e o overhead das chamadas polim√≥rficas √© significativo.
- Para casos onde objetos individuais e compostos t√™m comportamentos muito diferentes.
- Quando voc√™ precisa de forte tipagem e quer evitar opera√ß√µes inv√°lidas em tempo de compila√ß√£o.

---

## Padr√µes Relacionados

- **Decorator:** Adiciona responsabilidades a objetos dinamicamente.
- **Iterator:** Para percorrer elementos em estruturas compostas.
- **Visitor:** Para definir opera√ß√µes em estruturas compostas sem modificar as classes.

---

## Conclus√£o

O **Composite Pattern** √© uma solu√ß√£o elegante para trabalhar com estruturas hier√°rquicas complexas, permitindo que voc√™ trate objetos individuais e composi√ß√µes de forma uniforme. Ele promove c√≥digo limpo, flex√≠vel e facilmente extens√≠vel, sendo especialmente √∫til em sistemas que lidam com estruturas em √°rvore.

Este padr√£o √© fundamental em Java para frameworks de GUI, sistemas de arquivos, parsers de documentos e qualquer aplica√ß√£o que precise gerenciar hierarquias parte-todo. Se voc√™ trabalha com estruturas recursivas ou hier√°rquicas, o Composite Pattern √© uma ferramenta indispens√°vel para manter seu c√≥digo organizando e maint√≠vel.

---

Gostou deste post? Continue acompanhando para mais conte√∫dos sobre padr√µes de design e desenvolvimento em **Java**!