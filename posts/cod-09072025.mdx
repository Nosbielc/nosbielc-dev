---
title: "Proxy Pattern em Java: Controlando Acesso a Objetos com Efici√™ncia"
description: "Aprenda como implementar o Proxy Pattern em Java para controlar o acesso a objetos, implementar lazy loading e adicionar funcionalidades extras. Descubra como este padr√£o estrutural pode melhorar a performance e seguran√ßa das suas aplica√ß√µes."
date: Jul 09 2025
---

## Introdu√ß√£o

O **Proxy Pattern** (Padr√£o Proxy) √© um padr√£o de design estrutural que fornece um substituto ou marcador de posi√ß√£o para outro objeto, controlando o acesso a ele. Este padr√£o atua como um intermedi√°rio que pode adicionar funcionalidades extras como valida√ß√£o, cache, lazy loading ou controle de acesso, sem alterar a interface do objeto original.

Neste post, exploraremos o conceito do Proxy Pattern, suas vantagens e como implement√°-lo em Java com exemplos pr√°ticos que demonstram diferentes tipos de proxies e suas aplica√ß√µes em cen√°rios reais.

---

## O que √© o Proxy Pattern?

O Proxy Pattern resolve problemas relacionados ao controle de acesso, otimiza√ß√£o de recursos e adi√ß√£o de funcionalidades transparentes a objetos existentes. Em vez de permitir acesso direto ao objeto real, o padr√£o introduz um proxy que controla quando e como o objeto real √© acessado.

**Principais componentes:**

1. **Subject:** Interface comum que define as opera√ß√µes dispon√≠veis tanto para o objeto real quanto para o proxy.
2. **RealSubject:** A classe que cont√©m a l√≥gica de neg√≥cio real que queremos controlar o acesso.
3. **Proxy:** Mant√©m uma refer√™ncia ao objeto real e controla o acesso a ele, podendo adicionar funcionalidades extras.
4. **Client:** Usa o proxy atrav√©s da interface Subject, sem saber que est√° interagindo com um intermedi√°rio.

**Tipos comuns de Proxy:**

- **Virtual Proxy:** Controla o acesso a objetos caros de criar (lazy loading)
- **Protection Proxy:** Controla o acesso baseado em permiss√µes
- **Remote Proxy:** Representa um objeto localizado em outro espa√ßo de endere√ßo
- **Cache Proxy:** Adiciona cache para otimizar chamadas repetidas

---

## Quando usar o Proxy Pattern?

- Quando voc√™ precisa controlar o acesso a um objeto de forma transparente.
- Para implementar lazy loading de objetos caros de criar ou carregar.
- Quando voc√™ quer adicionar funcionalidades como cache, log ou valida√ß√£o sem modificar o objeto original.
- Para controlar acesso baseado em permiss√µes ou roles.
- Quando voc√™ precisa representar objetos remotos localmente.
- Para monitorar ou registrar o uso de um objeto.

---

## Exemplo Pr√°tico em Java

Vamos implementar diferentes tipos de proxies usando um sistema de acesso a imagens, demonstrando Virtual Proxy (lazy loading) e Protection Proxy (controle de acesso):

### 1. Definindo a Interface Subject

A interface comum para imagens reais e proxies:

```java
public interface Image {
    void display();
    String getFileName();
    long getFileSize();
}
```

### 2. Implementando o RealSubject

A classe que representa uma imagem real (cara de carregar):

```java
public class RealImage implements Image {
    private String fileName;
    private byte[] imageData;
    private long fileSize;
    
    public RealImage(String fileName) {
        this.fileName = fileName;
        loadImageFromDisk();
    }
    
    private void loadImageFromDisk() {
        System.out.println("Carregando imagem do disco: " + fileName);
        
        // Simula carregamento pesado do disco
        try {
            Thread.sleep(2000); // Simula tempo de carregamento
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Simula dados da imagem
        this.imageData = new byte[1024 * 1024]; // 1MB de dados simulados
        this.fileSize = imageData.length;
        
        System.out.println("Imagem " + fileName + " carregada com sucesso!");
    }
    
    @Override
    public void display() {
        System.out.println("Exibindo imagem: " + fileName + 
                         " (Tamanho: " + fileSize + " bytes)");
    }
    
    @Override
    public String getFileName() {
        return fileName;
    }
    
    @Override
    public long getFileSize() {
        return fileSize;
    }
}
```

### 3. Implementando o Virtual Proxy

Este proxy implementa lazy loading para otimizar o carregamento:

```java
public class VirtualImageProxy implements Image {
    private String fileName;
    private RealImage realImage;
    private long estimatedSize;
    
    public VirtualImageProxy(String fileName) {
        this.fileName = fileName;
        this.estimatedSize = estimateFileSize(fileName);
    }
    
    private long estimateFileSize(String fileName) {
        // Simula estimativa do tamanho sem carregar o arquivo
        return fileName.length() * 50000; // Estimativa baseada no nome
    }
    
    @Override
    public void display() {
        // Lazy loading: s√≥ carrega quando realmente precisa exibir
        if (realImage == null) {
            System.out.println("Virtual Proxy: Iniciando carregamento lazy da imagem...");
            realImage = new RealImage(fileName);
        }
        realImage.display();
    }
    
    @Override
    public String getFileName() {
        return fileName;
    }
    
    @Override
    public long getFileSize() {
        if (realImage != null) {
            return realImage.getFileSize();
        }
        return estimatedSize; // Retorna estimativa se ainda n√£o carregou
    }
}
```

### 4. Implementando o Protection Proxy

Este proxy controla o acesso baseado em permiss√µes:

```java
public class ProtectionImageProxy implements Image {
    private Image targetImage;
    private String userRole;
    private String requiredPermission;
    
    public ProtectionImageProxy(Image targetImage, String userRole, String requiredPermission) {
        this.targetImage = targetImage;
        this.userRole = userRole;
        this.requiredPermission = requiredPermission;
    }
    
    private boolean hasPermission() {
        // Simula verifica√ß√£o de permiss√µes
        if ("ADMIN".equals(userRole)) {
            return true; // Admin tem acesso a tudo
        }
        
        if ("CONFIDENTIAL".equals(requiredPermission) && "USER".equals(userRole)) {
            return false; // Usu√°rio comum n√£o pode ver imagens confidenciais
        }
        
        return "PUBLIC".equals(requiredPermission);
    }
    
    @Override
    public void display() {
        if (hasPermission()) {
            System.out.println("Protection Proxy: Acesso autorizado");
            targetImage.display();
        } else {
            System.out.println("Protection Proxy: ACESSO NEGADO - Permiss√£o insuficiente");
            System.out.println("Usu√°rio: " + userRole + " | Requerido: " + requiredPermission);
        }
    }
    
    @Override
    public String getFileName() {
        if (hasPermission()) {
            return targetImage.getFileName();
        }
        return "ACESSO_NEGADO.jpg";
    }
    
    @Override
    public long getFileSize() {
        if (hasPermission()) {
            return targetImage.getFileSize();
        }
        return 0; // N√£o revela informa√ß√µes se sem permiss√£o
    }
}
```

### 5. Implementando um Cache Proxy

Proxy que adiciona funcionalidade de cache:

```java
import java.util.HashMap;
import java.util.Map;

public class CacheImageProxy implements Image {
    private static final Map<String, String> displayCache = new HashMap<>();
    private Image targetImage;
    
    public CacheImageProxy(Image targetImage) {
        this.targetImage = targetImage;
    }
    
    @Override
    public void display() {
        String cacheKey = targetImage.getFileName();
        
        if (displayCache.containsKey(cacheKey)) {
            System.out.println("Cache Proxy: Exibindo do cache - " + displayCache.get(cacheKey));
        } else {
            System.out.println("Cache Proxy: N√£o encontrado no cache, carregando...");
            targetImage.display();
            
            // Adiciona ao cache
            displayCache.put(cacheKey, "Imagem " + cacheKey + " (cached)");
            System.out.println("Cache Proxy: Imagem adicionada ao cache");
        }
    }
    
    @Override
    public String getFileName() {
        return targetImage.getFileName();
    }
    
    @Override
    public long getFileSize() {
        return targetImage.getFileSize();
    }
    
    public static void clearCache() {
        displayCache.clear();
        System.out.println("Cache Proxy: Cache limpo");
    }
}
```

### 6. Criando o Cliente

Exemplo demonstrando o uso dos diferentes proxies:

```java
public class ProxyPatternDemo {
    public static void main(String[] args) {
        System.out.println("=== Demonstra√ß√£o do Proxy Pattern ===\n");
        
        // 1. Virtual Proxy - Lazy Loading
        System.out.println("1. VIRTUAL PROXY (Lazy Loading):");
        Image virtualProxy = new VirtualImageProxy("foto_familia.jpg");
        
        System.out.println("Obtendo informa√ß√µes sem carregar:");
        System.out.println("Nome: " + virtualProxy.getFileName());
        System.out.println("Tamanho estimado: " + virtualProxy.getFileSize() + " bytes");
        
        System.out.println("\nPrimeira exibi√ß√£o (vai carregar):");
        virtualProxy.display();
        
        System.out.println("\nSegunda exibi√ß√£o (j√° carregado):");
        virtualProxy.display();
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // 2. Protection Proxy - Controle de Acesso
        System.out.println("2. PROTECTION PROXY (Controle de Acesso):");
        
        Image realImage = new RealImage("documento_confidencial.pdf");
        
        // Usu√°rio comum tentando acessar documento confidencial
        Image protectedProxyUser = new ProtectionImageProxy(realImage, "USER", "CONFIDENTIAL");
        System.out.println("\nUsu√°rio comum tentando acessar:");
        protectedProxyUser.display();
        
        // Admin acessando o mesmo documento
        Image protectedProxyAdmin = new ProtectionImageProxy(realImage, "ADMIN", "CONFIDENTIAL");
        System.out.println("\nAdmin acessando:");
        protectedProxyAdmin.display();
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // 3. Cache Proxy
        System.out.println("3. CACHE PROXY:");
        Image baseImage = new VirtualImageProxy("banner_site.png");
        Image cachedProxy = new CacheImageProxy(baseImage);
        
        System.out.println("\nPrimeira exibi√ß√£o (n√£o est√° no cache):");
        cachedProxy.display();
        
        System.out.println("\nSegunda exibi√ß√£o (do cache):");
        cachedProxy.display();
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // 4. Combinando Proxies
        System.out.println("4. COMBINANDO PROXIES:");
        Image realImg = new RealImage("relatorio_vendas.jpg");
        Image protectedImg = new ProtectionImageProxy(realImg, "ADMIN", "CONFIDENTIAL");
        Image cachedProtectedImg = new CacheImageProxy(protectedImg);
        
        System.out.println("\nProxy combinado (Protection + Cache):");
        cachedProtectedImg.display();
        cachedProtectedImg.display(); // Segunda chamada usa cache
        
        // Limpando cache para demonstra√ß√£o
        CacheImageProxy.clearCache();
    }
}
```

### Sa√≠da do Programa

```
=== Demonstra√ß√£o do Proxy Pattern ===

1. VIRTUAL PROXY (Lazy Loading):
Obtendo informa√ß√µes sem carregar:
Nome: foto_familia.jpg
Tamanho estimado: 800000 bytes

Primeira exibi√ß√£o (vai carregar):
Virtual Proxy: Iniciando carregamento lazy da imagem...
Carregando imagem do disco: foto_familia.jpg
Imagem foto_familia.jpg carregada com sucesso!
Exibindo imagem: foto_familia.jpg (Tamanho: 1048576 bytes)

Segunda exibi√ß√£o (j√° carregado):
Exibindo imagem: foto_familia.jpg (Tamanho: 1048576 bytes)

==================================================

2. PROTECTION PROXY (Controle de Acesso):
Carregando imagem do disco: documento_confidencial.pdf
Imagem documento_confidencial.pdf carregada com sucesso!

Usu√°rio comum tentando acessar:
Protection Proxy: ACESSO NEGADO - Permiss√£o insuficiente
Usu√°rio: USER | Requerido: CONFIDENTIAL

Admin acessando:
Protection Proxy: Acesso autorizado
Exibindo imagem: documento_confidencial.pdf (Tamanho: 1048576 bytes)

==================================================

3. CACHE PROXY:

Primeira exibi√ß√£o (n√£o est√° no cache):
Cache Proxy: N√£o encontrado no cache, carregando...
Virtual Proxy: Iniciando carregamento lazy da imagem...
Carregando imagem do disco: banner_site.png
Imagem banner_site.png carregada com sucesso!
Exibindo imagem: banner_site.png (Tamanho: 1048576 bytes)
Cache Proxy: Imagem adicionada ao cache

Segunda exibi√ß√£o (do cache):
Cache Proxy: Exibindo do cache - Imagem banner_site.png (cached)

==================================================

4. COMBINANDO PROXIES:

Proxy combinado (Protection + Cache):
Cache Proxy: N√£o encontrado no cache, carregando...
Protection Proxy: Acesso autorizado
Exibindo imagem: relatorio_vendas.jpg (Tamanho: 1048576 bytes)
Cache Proxy: Imagem adicionada ao cache
Cache Proxy: Exibindo do cache - Imagem relatorio_vendas.jpg (cached)
Cache Proxy: Cache limpo
```

### Explica√ß√£o do C√≥digo

1. **Virtual Proxy:** Implementa lazy loading, s√≥ carregando a imagem real quando necess√°rio para exibi√ß√£o, otimizando recursos.

2. **Protection Proxy:** Controla acesso baseado em roles e permiss√µes, garantindo seguran√ßa sem modificar o objeto original.

3. **Cache Proxy:** Adiciona funcionalidade de cache transparente, melhorando performance em acessos repetidos.

4. **Combina√ß√£o de Proxies:** Demonstra como diferentes proxies podem ser combinados para criar funcionalidades complexas.

---

## Vantagens do Proxy Pattern

1. **Controle de Acesso:** Permite controlar quando e como um objeto √© acessado sem modificar sua interface.

2. **Otimiza√ß√£o de Recursos:** Implementa lazy loading e cache para melhorar performance.

3. **Transpar√™ncia:** O cliente usa o proxy da mesma forma que usaria o objeto real.

4. **Flexibilidade:** Permite adicionar funcionalidades extras (log, valida√ß√£o, cache) sem alterar o c√≥digo existente.

5. **Seguran√ßa:** Pode implementar controles de acesso e valida√ß√£o antes de delegar ao objeto real.

6. **Desacoplamento:** Separa as preocupa√ß√µes de controle de acesso da l√≥gica de neg√≥cio principal.

---

## Desvantagens do Proxy Pattern

1. **Complexidade Adicional:** Adiciona uma camada extra que pode complicar o c√≥digo.

2. **Overhead de Performance:** Cada chamada passa pelo proxy, podendo introduzir lat√™ncia.

3. **Manuten√ß√£o:** Proxies precisam ser mantidos sincronizados com mudan√ßas na interface do objeto real.

4. **Debugging Dif√≠cil:** Pode ser mais dif√≠cil debuggar problemas quando h√° m√∫ltiplas camadas de proxies.

---

## Quando evitar o Proxy Pattern?

- Quando o objeto real √© simples e n√£o justifica a complexidade adicional do proxy.
- Se a performance √© cr√≠tica e o overhead do proxy √© inaceit√°vel.
- Quando voc√™ precisa de acesso direto √†s implementa√ß√µes espec√≠ficas do objeto real.
- Para objetos que s√£o sempre necess√°rios (n√£o se beneficiam de lazy loading).
- Quando a interface do objeto real muda frequentemente, tornando dif√≠cil manter o proxy sincronizado.

---

## Padr√µes Relacionados

- **Decorator Pattern:** Ambos adicionam funcionalidades a objetos, mas Decorator foca em adicionar responsabilidades enquanto Proxy foca em controlar acesso.
- **Adapter Pattern:** Ambos atuam como intermedi√°rios, mas Adapter adapta interfaces incompat√≠veis enquanto Proxy mant√©m a mesma interface.
- **Facade Pattern:** Ambos fornecem uma interface simplificada, mas Facade simplifica m√∫ltiplas interfaces enquanto Proxy controla acesso a uma √∫nica interface.

---

## Conclus√£o

O **Proxy Pattern** √© uma ferramenta poderosa para controlar o acesso a objetos, implementar otimiza√ß√µes como lazy loading e cache, e adicionar funcionalidades de seguran√ßa de forma transparente. Sua flexibilidade permite que seja usado em diversos cen√°rios, desde otimiza√ß√£o de recursos at√© controle de seguran√ßa.

A chave para o sucesso na implementa√ß√£o do Proxy Pattern est√° em identificar corretamente quando o controle de acesso ou funcionalidades extras s√£o necess√°rios, e escolher o tipo de proxy apropriado para cada situa√ß√£o. Seja para melhorar performance com lazy loading, implementar seguran√ßa com controle de acesso, ou adicionar cache para otimiza√ß√£o, o Proxy Pattern oferece uma solu√ß√£o elegante e reutiliz√°vel.

---

Gostou deste post? Continue acompanhando para mais conte√∫dos sobre padr√µes de design e desenvolvimento em **Java**!
---

**üîó Reposit√≥rio de Exemplos**

Aqui o link para nosso laborat√≥rio: [https://github.com/Nosbielc/nosbielc-dev-demos](https://github.com/Nosbielc/nosbielc-dev-demos)