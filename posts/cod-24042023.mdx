---
title: "Resilience4J e Spring Boot: Construindo aplica√ß√µes robustas e resilientes"
description: "Descubra como utilizar o Resilience4J com o Spring Boot para criar aplica√ß√µes mais resistentes a falhas e resilientes."
date: Apr 24 2023
---

Hoje, vamos falar sobre Resilience4J, uma biblioteca de toler√¢ncia a falhas leve e f√°cil de usar, e como implement√°-la em conjunto com o Spring Boot para construir aplica√ß√µes mais robustas e resilientes.

1. _O que √© Resilience4J?_

    Resilience4J √© uma biblioteca de toler√¢ncia a falhas para Java 8+, baseada nos padr√µes de projeto de resili√™ncia do Netflix Hystrix. Ela oferece v√°rios m√≥dulos, como Circuit Breaker, Rate Limiter, Retry e Bulkhead, que ajudam a criar aplica√ß√µes mais resilientes e a lidar com falhas tempor√°rias ou permanentes em servi√ßos dependentes.

2. _Integrando Resilience4J com Spring Boot_

    Para come√ßar, adicione as depend√™ncias necess√°rias ao seu arquivo pom.xml:

     ```xml
     <dependencies>
         <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-actuator</artifactId>
         </dependency>
         <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-aop</artifactId>
         </dependency>

         <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-devtools</artifactId>
             <scope>runtime</scope>
             <optional>true</optional>
         </dependency>
         <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-configuration-processor</artifactId>
             <optional>true</optional>
         </dependency>
         <dependency>
             <groupId>org.projectlombok</groupId>
             <artifactId>lombok</artifactId>
             <optional>true</optional>
         </dependency>
         <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-test</artifactId>
             <scope>test</scope>
         </dependency>

         <!-- https://mvnrepository.com/artifact/io.github.resilience4j/resilience4j-spring-boot3 -->
         <dependency>
             <groupId>io.github.resilience4j</groupId>
             <artifactId>resilience4j-spring-boot3</artifactId>
             <version>2.0.2</version>
         </dependency>

         <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-data-jpa</artifactId>
         </dependency>
         <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-data-rest</artifactId>
         </dependency>
         <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-validation</artifactId>
         </dependency>
         <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-web</artifactId>
         </dependency>

         <dependency>
             <groupId>com.h2database</groupId>
             <artifactId>h2</artifactId>
             <scope>runtime</scope>
         </dependency>

     </dependencies>
   ```

    Agora, voc√™ pode configurar o Resilience4J no arquivo application.yml:

     ```yaml
     resilience4j:
         circuitbreaker:
             instances:
                 UserService:
                     slidingWindowSize: 10
                     failureRateThreshold: 50
                     waitDurationInOpenState: 1000
                     slowCallRateThreshold: 50
                     slowCallDurationThreshold: 500
                     permittedNumberOfCallsInHalfOpenState: 3
                     automaticTransitionFromOpenToHalfOpenEnabled: true
                     ratelimiter:
                     instances:
                     UserService:
                     limitForPeriod: 10
                     limitRefreshPeriod: 1000
                     timeoutDuration: 0
         retry:
             instances:
                 UserService:
                     maxAttempts: 3
                     waitDuration: 1000
                     retryExceptions:
                     - java.io.IOException
         bulkhead:
             instances:
                 UserService:
                     maxConcurrentCalls: 5
                     maxWaitDuration: 500
     ```

    Vamos criar um exemplo simples de como usar o Resilience4J com Spring Boot. Primeiro, crie uma interface UserService:

     ```java
     public interface UserService {
         User login(Long id);
     }
        ```

    Em seguida, implemente a interface UserService:

     ```java
     @Service
     @RequiredArgsConstructor
     public class UserServiceImpl implements UserService {

         private final UserRepository userRepository;

         @Override
         public User login(Long id) {
             return userRepository.findById(id).orElseThrow();
         }
     }
     ```

    Agora, voc√™ pode criar um CircuitBreaker e um RateLimiter para o servi√ßo usando anota√ß√µes:

     ```java
     @Service
     @RequiredArgsConstructor
     public class ResilientUserService implements UserService {

         private final UserService userService;

         @CircuitBreaker(name = "userService", fallbackMethod = "fallbackCircuitBreaker")
         @Retry(name = "userService", fallbackMethod = "fallbackRetry")
         @Bulkhead(name = "userService")
         @RateLimiter(name = "userService")
         @Override
         public User login(Long id) {
             return userService.login(id);
         }

         private User fallbackCircuitBreaker(Throwable throwable){
             return User.builder().withAge(1000).withId(-1L).withEmail("default@email.com").withFirstName("CircuitBreaker").withLastName("Sem nome de famila").build();
         }

         private User fallbackRetry(Throwable throwable){
             return User.builder().withAge(1000).withId(-1L).withEmail("default@email.com").withFirstName("Retry").withLastName("Sem nome de famila").build();
         }
     }
     ```

    No exemplo acima, criamos um servi√ßo `ResilientUserService` que encapsula o `UserService` e aplica as anota√ß√µes `@CircuitBreaker` e `@RateLimiter`. Isso garante que o servi√ßo seja resiliente √†s falhas e limita a taxa de chamadas para evitar sobrecarga.

    Finalmente, vamos criar um controlador para expor o servi√ßo atrav√©s de uma API REST:

     ```java
     @RestController("/front")
     public class UserController {

         private final UserService userService;

         @Autowired
         public UserController(ResilientUserService resilientUserService) {
             this.userService = resilientUserService;
         }

         @GetMapping("/user/{id}")
         public ResponseEntity<User> login(@PathVariable Long id){
             return ResponseEntity.ok(userService.login(id));
         }

     }
    ```

    Agora, ao acessar a rota /front/user/{id}, o controlador ir√° utilizar o servi√ßo ResilientUserService, que aplicar√° o Circuit Breaker e o Rate Limiter para proteger a aplica√ß√£o contra falhas e sobrecarga.

3. _Modulos do Resilience4J_

    _Circuit Breaker:_

     - O Circuit Breaker √© um padr√£o que protege sua aplica√ß√£o de falhas em servi√ßos dependentes, interrompendo temporariamente a execu√ß√£o de chamadas em caso de falha recorrente e permitindo que o servi√ßo se recupere.

    _Rate Limiter:_

     - O Rate Limiter limita a taxa de chamadas a um servi√ßo, evitando sobrecarga e garantindo uma melhor distribui√ß√£o de recursos.

    _Retry_

     - O Retry permite que sua aplica√ß√£o tente novamente uma chamada em caso de falha tempor√°ria, com a possibilidade de configurar o n√∫mero m√°ximo de tentativas e o intervalo entre elas.

    _Bulkhead_

     - O Bulkhead isola recursos e limita o n√∫mero de chamadas simult√¢neas a um servi√ßo, evitando que falhas em um servi√ßo afetem outros servi√ßos e garantindo uma melhor distribui√ß√£o de recursos.

    Voc√™ pode combinar esses m√≥dulos para criar uma solu√ß√£o de resili√™ncia mais completa e personalizada para suas necessidades.

4. _Arquivo application.yml em detalhes_

    **Circuit Breaker:**

     - slidingWindowSize: Define o tamanho da janela deslizante que √© usada para contar o n√∫mero de chamadas e calcular a taxa de falhas.
     - failureRateThreshold: Define o limite de taxa de falha que, quando excedido, faz com que o circuito abra (ou seja, pare de fazer chamadas para o servi√ßo).
     - waitDurationInOpenState: Define o tempo de espera em milissegundos que o circuito permanecer√° aberto antes de mudar para o estado "half-open" e tentar uma chamada novamente.
     - slowCallRateThreshold: Define o limite de taxa de chamadas lentas que, quando excedido, faz com que o circuito abra.
     - slowCallDurationThreshold: Define o tempo limite em milissegundos para considerar uma chamada como lenta.
     - permittedNumberOfCallsInHalfOpenState: Define o n√∫mero m√°ximo de chamadas permitidas no estado "half-open".
     - automaticTransitionFromOpenToHalfOpenEnabled: Se verdadeiro, o circuito mudar√° automaticamente do estado aberto para o estado "half-open" ap√≥s o tempo de espera definido em waitDurationInOpenState.

    **Rate Limiter:**

     - limitForPeriod: Define o limite de chamadas permitidas para um determinado per√≠odo.
     - limitRefreshPeriod: Define o per√≠odo de tempo em milissegundos em que o limite de chamadas ser√° atualizado.
     - timeoutDuration: Define o tempo de espera em milissegundos antes que uma chamada seja rejeitada quando o limite de taxa for excedido.

    **Retry:**

     - maxAttempts: Define o n√∫mero m√°ximo de tentativas antes que a opera√ß√£o seja considerada como falha.
     - waitDuration: Define o tempo de espera em milissegundos entre as tentativas.
     - retryExceptions: Lista de exce√ß√µes para as quais a opera√ß√£o ser√° tentada novamente.
     - ignoreExceptions: Lista de exce√ß√µes que ser√£o ignoradas e n√£o far√£o com que a opera√ß√£o seja tentada novamente.

    **Bulkhead:**

     - maxConcurrentCalls: Define o n√∫mero m√°ximo de chamadas simult√¢neas permitidas.
     - maxWaitDuration: Define o tempo m√°ximo de espera em milissegundos antes que uma chamada seja rejeitada quando o limite de chamadas simult√¢neas for atingido.

    Cada configura√ß√£o pode ser personalizada para se adequar √†s necessidades espec√≠ficas de sua aplica√ß√£o. Algumas dicas adicionais:

     - √â importante ajustar os valores de configura√ß√£o para corresponder √†s caracter√≠sticas de desempenho e falha do servi√ßo que voc√™ est√° protegendo. Por exemplo, se o servi√ßo demora muito para responder, voc√™ pode aumentar o valor de **slowCallDurationThreshold** no Circuit Breaker.
     - Ao combinar os m√≥dulos, como Circuit Breaker e Rate Limiter, certifique-se de que as configura√ß√µes funcionam bem em conjunto. Por exemplo, voc√™ pode querer limitar a taxa de chamadas usando o Rate Limiter para evitar que o Circuit Breaker seja acionado com muita frequ√™ncia.
     - Considere as implica√ß√µes de desempenho e lat√™ncia ao configurar o Retry. Retentar muitas vezes com um intervalo de espera muito curto pode aumentar a carga no servi√ßo e piorar o problema. Um valor mais conservador para **maxAttempts** e um intervalo de espera crescente entre tentativas podem ser mais eficazes.
     - Ao configurar o Bulkhead, equilibre o n√∫mero m√°ximo de chamadas simult√¢neas com a capacidade do servi√ßo e os recursos do sistema. Se o valor de **maxConcurrentCalls** for muito alto, o servi√ßo pode ficar sobrecarregado. Se for muito baixo, voc√™ pode limitar desnecessariamente a capacidade de processamento da aplica√ß√£o.

    Lembre-se de testar e monitorar sua aplica√ß√£o para garantir que as configura√ß√µes do Resilience4J estejam funcionando conforme o esperado e proporcionando o n√≠vel de resili√™ncia necess√°rio.

---

**Conclus√£o**

Neste post, apresentamos o Resilience4J e como integr√°-lo com o Spring Boot para criar aplica√ß√µes mais robustas e resilientes. O Resilience4J oferece v√°rias estrat√©gias de toler√¢ncia a falhas, como Circuit Breaker, Rate Limiter, Retry e Bulkhead, que podem ser facilmente aplicadas √†s suas aplica√ß√µes Spring Boot. N√£o se esque√ßa de explorar a documenta√ß√£o do Resilience4J para descobrir todas as possibilidades e personalizar ainda mais o comportamento da sua aplica√ß√£o.

_Acesse aqui os fontes deste post_ [link](https://github.com/Nosbielc/blog-spring-resilience4J)
---

**üîó Reposit√≥rio de Exemplos**

Aqui o link para nosso laborat√≥rio: [https://github.com/Nosbielc/nosbielc-dev-demos](https://github.com/Nosbielc/nosbielc-dev-demos)