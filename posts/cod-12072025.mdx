---
title: "Memento Pattern em Java: Capturando e Restaurando Estados de Objetos"
description: "Aprenda como implementar o Memento Pattern em Java para capturar e restaurar estados de objetos sem violar encapsulamento. Descubra como este padr√£o comportamental permite criar funcionalidades de undo/redo, checkpoints e versionamento de estado com exemplos pr√°ticos."
date: Jul 12 2025
---

## Introdu√ß√£o

O **Memento Pattern** (Padr√£o Memento) √© um padr√£o de design comportamental que permite capturar e externalizar o estado interno de um objeto sem violar seu encapsulamento, de modo que o objeto possa ser restaurado para este estado posteriormente. Este padr√£o √© fundamental para implementar funcionalidades como undo/redo, checkpoints, snapshots e versionamento de estado.

Neste post, exploraremos o conceito do Memento Pattern, suas vantagens e como implement√°-lo em Java com exemplos pr√°ticos que demonstram como criar um sistema de editor de texto com funcionalidade completa de desfazer/refazer e gerenciamento de hist√≥rico de estados.

---

## O que √© o Memento Pattern?

O Memento Pattern resolve o problema de capturar e restaurar o estado de um objeto sem expor seus detalhes internos ou violar o princ√≠pio de encapsulamento. Em vez de permitir acesso direto aos campos privados do objeto, o padr√£o usa um objeto intermedi√°rio (memento) que armazena o estado de forma segura.

**Principais componentes:**

1. **Originator:** O objeto cujo estado precisa ser salvo e restaurado.
2. **Memento:** Objeto que armazena o estado interno do Originator de forma imut√°vel.
3. **Caretaker:** Respons√°vel por gerenciar os mementos, mas sem acessar ou modificar seu conte√∫do.

**Caracter√≠sticas principais:**

- **Preserva√ß√£o do Encapsulamento:** O estado √© capturado sem expor a estrutura interna do objeto.
- **Undo/Redo:** Permite implementar funcionalidades de desfazer e refazer opera√ß√µes.
- **Snapshots:** Cria pontos de restaura√ß√£o do estado de objetos.
- **Versionamento:** Mant√©m hist√≥rico de diferentes vers√µes do estado.

---

## Quando usar o Memento Pattern?

- Quando voc√™ precisa implementar funcionalidades de undo/redo em sua aplica√ß√£o.
- Para criar checkpoints ou snapshots do estado de objetos complexos.
- Quando voc√™ quer salvar e restaurar o estado de um objeto sem violar encapsulamento.
- Para implementar sistemas de versionamento ou controle de mudan√ßas.
- Quando voc√™ precisa reverter opera√ß√µes que modificam o estado de objetos.
- Para criar funcionalidades de backup tempor√°rio durante opera√ß√µes cr√≠ticas.

---

## Exemplo Pr√°tico em Java

Vamos implementar um sistema de editor de texto completo com funcionalidades de undo/redo, demonstrando diferentes aspectos do Memento Pattern:

### 1. Definindo o Memento

A classe que armazena o estado de forma imut√°vel:

```java
public class TextMemento {
    private final String content;
    private final int cursorPosition;
    private final boolean isModified;
    private final long timestamp;
    
    // Construtor package-private para controlar acesso
    TextMemento(String content, int cursorPosition, boolean isModified) {
        this.content = content;
        this.cursorPosition = cursorPosition;
        this.isModified = isModified;
        this.timestamp = System.currentTimeMillis();
    }
    
    // M√©todos package-private para acesso controlado
    String getContent() {
        return content;
    }
    
    int getCursorPosition() {
        return cursorPosition;
    }
    
    boolean isModified() {
        return isModified;
    }
    
    public long getTimestamp() {
        return timestamp;
    }
    
    @Override
    public String toString() {
        return "TextMemento{" +
                "content='" + (content.length() > 20 ? content.substring(0, 20) + "..." : content) + "'" +
                ", cursorPosition=" + cursorPosition +
                ", isModified=" + isModified +
                ", timestamp=" + timestamp +
                '}';
    }
}
```

### 2. Implementando o Originator

A classe TextEditor que precisa ter seu estado salvo e restaurado:

```java
public class TextEditor {
    private StringBuilder content;
    private int cursorPosition;
    private boolean isModified;
    private String fileName;
    
    public TextEditor() {
        this.content = new StringBuilder();
        this.cursorPosition = 0;
        this.isModified = false;
        this.fileName = "Untitled";
    }
    
    public TextEditor(String fileName) {
        this();
        this.fileName = fileName;
    }
    
    // M√©todo para criar um memento com o estado atual
    public TextMemento createMemento() {
        return new TextMemento(
            content.toString(), 
            cursorPosition, 
            isModified
        );
    }
    
    // M√©todo para restaurar o estado a partir de um memento
    public void restoreFromMemento(TextMemento memento) {
        this.content = new StringBuilder(memento.getContent());
        this.cursorPosition = memento.getCursorPosition();
        this.isModified = memento.isModified();
    }
    
    // Opera√ß√µes do editor
    public void insertText(String text) {
        content.insert(cursorPosition, text);
        cursorPosition += text.length();
        isModified = true;
    }
    
    public void deleteText(int length) {
        if (cursorPosition >= length) {
            content.delete(cursorPosition - length, cursorPosition);
            cursorPosition -= length;
            isModified = true;
        }
    }
    
    public void replaceText(int start, int end, String newText) {
        if (start >= 0 && end <= content.length() && start <= end) {
            content.replace(start, end, newText);
            cursorPosition = start + newText.length();
            isModified = true;
        }
    }
    
    public void moveCursor(int newPosition) {
        if (newPosition >= 0 && newPosition <= content.length()) {
            cursorPosition = newPosition;
        }
    }
    
    public void selectAll() {
        cursorPosition = content.length();
    }
    
    public void clear() {
        content.setLength(0);
        cursorPosition = 0;
        isModified = true;
    }
    
    // Getters
    public String getContent() {
        return content.toString();
    }
    
    public int getCursorPosition() {
        return cursorPosition;
    }
    
    public boolean isModified() {
        return isModified;
    }
    
    public String getFileName() {
        return fileName;
    }
    
    public void setFileName(String fileName) {
        this.fileName = fileName;
    }
    
    public void markAsUnmodified() {
        this.isModified = false;
    }
    
    @Override
    public String toString() {
        return "TextEditor{" +
                "fileName='" + fileName + "'" +
                ", content='" + (content.length() > 30 ? content.substring(0, 30) + "..." : content) + "'" +
                ", cursorPosition=" + cursorPosition +
                ", isModified=" + isModified +
                '}';
    }
}
```

### 3. Implementando o Caretaker

O gerenciador de hist√≥rico que controla os mementos:

```java
import java.util.*;

public class EditorHistory {
    private final Stack<TextMemento> undoStack;
    private final Stack<TextMemento> redoStack;
    private final int maxHistorySize;
    private final List<HistoryObserver> observers;
    
    public EditorHistory() {
        this(50); // Limite padr√£o de 50 estados
    }
    
    public EditorHistory(int maxHistorySize) {
        this.maxHistorySize = maxHistorySize;
        this.undoStack = new Stack<>();
        this.redoStack = new Stack<>();
        this.observers = new ArrayList<>();
    }
    
    // Salva o estado atual
    public void saveState(TextMemento memento) {
        // Limpa o stack de redo quando uma nova a√ß√£o √© executada
        redoStack.clear();
        
        // Adiciona o memento ao stack de undo
        undoStack.push(memento);
        
        // Limita o tamanho do hist√≥rico
        if (undoStack.size() > maxHistorySize) {
            undoStack.removeElementAt(0);
        }
        
        notifyObservers();
    }
    
    // Desfaz a √∫ltima opera√ß√£o
    public TextMemento undo() {
        if (!undoStack.isEmpty()) {
            TextMemento currentState = undoStack.pop();
            redoStack.push(currentState);
            notifyObservers();
            
            // Retorna o estado anterior (se existir)
            return undoStack.isEmpty() ? null : undoStack.peek();
        }
        return null;
    }
    
    // Refaz a √∫ltima opera√ß√£o desfeita
    public TextMemento redo() {
        if (!redoStack.isEmpty()) {
            TextMemento stateToRestore = redoStack.pop();
            undoStack.push(stateToRestore);
            notifyObservers();
            return stateToRestore;
        }
        return null;
    }
    
    // Verifica se √© poss√≠vel desfazer
    public boolean canUndo() {
        return undoStack.size() > 1; // Mant√©m pelo menos um estado
    }
    
    // Verifica se √© poss√≠vel refazer
    public boolean canRedo() {
        return !redoStack.isEmpty();
    }
    
    // Limpa todo o hist√≥rico
    public void clear() {
        undoStack.clear();
        redoStack.clear();
        notifyObservers();
    }
    
    // Obt√©m informa√ß√µes sobre o hist√≥rico
    public int getUndoStackSize() {
        return undoStack.size();
    }
    
    public int getRedoStackSize() {
        return redoStack.size();
    }
    
    public List<TextMemento> getUndoHistory() {
        return new ArrayList<>(undoStack);
    }
    
    public List<TextMemento> getRedoHistory() {
        return new ArrayList<>(redoStack);
    }
    
    // Padr√£o Observer para notificar mudan√ßas no hist√≥rico
    public interface HistoryObserver {
        void onHistoryChanged(boolean canUndo, boolean canRedo);
    }
    
    public void addObserver(HistoryObserver observer) {
        observers.add(observer);
    }
    
    public void removeObserver(HistoryObserver observer) {
        observers.remove(observer);
    }
    
    private void notifyObservers() {
        for (HistoryObserver observer : observers) {
            observer.onHistoryChanged(canUndo(), canRedo());
        }
    }
    
    @Override
    public String toString() {
        return "EditorHistory{" +
                "undoStackSize=" + undoStack.size() +
                ", redoStackSize=" + redoStack.size() +
                ", maxHistorySize=" + maxHistorySize +
                '}';
    }
}
```

### 4. Criando um Command Pattern Integrado

Para opera√ß√µes mais complexas, vamos integrar com Command Pattern:

```java
// Interface para comandos do editor
public interface EditorCommand {
    void execute();
    void undo();
    String getDescription();
}

// Comando para inserir texto
public class InsertTextCommand implements EditorCommand {
    private final TextEditor editor;
    private final String text;
    private final int insertPosition;
    
    public InsertTextCommand(TextEditor editor, String text) {
        this.editor = editor;
        this.text = text;
        this.insertPosition = editor.getCursorPosition();
    }
    
    @Override
    public void execute() {
        editor.insertText(text);
    }
    
    @Override
    public void undo() {
        editor.moveCursor(insertPosition + text.length());
        editor.deleteText(text.length());
    }
    
    @Override
    public String getDescription() {
        return "Insert: '" + text + "'";
    }
}

// Comando para deletar texto
public class DeleteTextCommand implements EditorCommand {
    private final TextEditor editor;
    private final int length;
    private final int deletePosition;
    private String deletedText;
    
    public DeleteTextCommand(TextEditor editor, int length) {
        this.editor = editor;
        this.length = length;
        this.deletePosition = editor.getCursorPosition();
    }
    
    @Override
    public void execute() {
        // Salva o texto que ser√° deletado para poder desfazer
        int start = Math.max(0, deletePosition - length);
        int end = deletePosition;
        deletedText = editor.getContent().substring(start, end);
        editor.deleteText(length);
    }
    
    @Override
    public void undo() {
        editor.moveCursor(deletePosition - length);
        editor.insertText(deletedText);
    }
    
    @Override
    public String getDescription() {
        return "Delete: '" + (deletedText != null ? deletedText : length + " chars") + "'";
    }
}

// Comando macro que agrupa m√∫ltiplos comandos
public class MacroCommand implements EditorCommand {
    private final List<EditorCommand> commands;
    private final String description;
    
    public MacroCommand(String description) {
        this.description = description;
        this.commands = new ArrayList<>();
    }
    
    public void addCommand(EditorCommand command) {
        commands.add(command);
    }
    
    @Override
    public void execute() {
        for (EditorCommand command : commands) {
            command.execute();
        }
    }
    
    @Override
    public void undo() {
        // Desfaz na ordem reversa
        for (int i = commands.size() - 1; i >= 0; i--) {
            commands.get(i).undo();
        }
    }
    
    @Override
    public String getDescription() {
        return description + " (" + commands.size() + " operations)";
    }
}
```

### 5. Implementando um Editor Completo

Sistema completo que integra todos os componentes:

```java
public class AdvancedTextEditor {
    private final TextEditor editor;
    private final EditorHistory history;
    private final Stack<EditorCommand> commandHistory;
    private boolean autoSave;
    
    public AdvancedTextEditor() {
        this.editor = new TextEditor();
        this.history = new EditorHistory();
        this.commandHistory = new Stack<>();
        this.autoSave = true;
        
        // Salva o estado inicial
        saveCurrentState();
        
        // Configura observer para hist√≥rico
        history.addObserver((canUndo, canRedo) -> {
            System.out.println("History changed - Can Undo: " + canUndo + ", Can Redo: " + canRedo);
        });
    }
    
    // Executa um comando e salva o estado
    public void executeCommand(EditorCommand command) {
        command.execute();
        commandHistory.push(command);
        
        if (autoSave) {
            saveCurrentState();
        }
    }
    
    // Opera√ß√µes convenientes do editor
    public void insertText(String text) {
        executeCommand(new InsertTextCommand(editor, text));
    }
    
    public void deleteText(int length) {
        executeCommand(new DeleteTextCommand(editor, length));
    }
    
    public void replaceAll(String oldText, String newText) {
        MacroCommand macro = new MacroCommand("Replace All '" + oldText + "' with '" + newText + "'");
        
        String content = editor.getContent();
        int index = 0;
        
        while ((index = content.indexOf(oldText, index)) != -1) {
            final int currentIndex = index;
            macro.addCommand(new EditorCommand() {
                @Override
                public void execute() {
                    editor.moveCursor(currentIndex + oldText.length());
                    editor.deleteText(oldText.length());
                    editor.insertText(newText);
                }
                
                @Override
                public void undo() {
                    editor.moveCursor(currentIndex + newText.length());
                    editor.deleteText(newText.length());
                    editor.insertText(oldText);
                }
                
                @Override
                public String getDescription() {
                    return "Replace at position " + currentIndex;
                }
            });
            
            content = content.substring(0, index) + newText + content.substring(index + oldText.length());
            index += newText.length();
        }
        
        if (!macro.commands.isEmpty()) {
            executeCommand(macro);
        }
    }
    
    // Salva o estado atual
    public void saveCurrentState() {
        TextMemento memento = editor.createMemento();
        history.saveState(memento);
    }
    
    // Desfaz a √∫ltima opera√ß√£o
    public boolean undo() {
        TextMemento previousState = history.undo();
        if (previousState != null) {
            editor.restoreFromMemento(previousState);
            return true;
        }
        return false;
    }
    
    // Refaz a √∫ltima opera√ß√£o desfeita
    public boolean redo() {
        TextMemento stateToRestore = history.redo();
        if (stateToRestore != null) {
            editor.restoreFromMemento(stateToRestore);
            return true;
        }
        return false;
    }
    
    // Cria um snapshot nomeado
    public void createSnapshot(String name) {
        System.out.println("Creating snapshot: " + name);
        saveCurrentState();
    }
    
    // Funcionalidades de gerenciamento
    public void setAutoSave(boolean autoSave) {
        this.autoSave = autoSave;
    }
    
    public boolean canUndo() {
        return history.canUndo();
    }
    
    public boolean canRedo() {
        return history.canRedo();
    }
    
    public void clearHistory() {
        history.clear();
        commandHistory.clear();
        saveCurrentState(); // Salva o estado atual como novo ponto de partida
    }
    
    // Getters para acessar informa√ß√µes
    public String getContent() {
        return editor.getContent();
    }
    
    public TextEditor getEditor() {
        return editor;
    }
    
    public EditorHistory getHistory() {
        return history;
    }
    
    public void showStats() {
        System.out.println("=== EDITOR STATISTICS ===");
        System.out.println("Content length: " + editor.getContent().length());
        System.out.println("Cursor position: " + editor.getCursorPosition());
        System.out.println("Modified: " + editor.isModified());
        System.out.println("Commands executed: " + commandHistory.size());
        System.out.println("Undo stack size: " + history.getUndoStackSize());
        System.out.println("Redo stack size: " + history.getRedoStackSize());
        System.out.println("Can undo: " + canUndo());
        System.out.println("Can redo: " + canRedo());
        System.out.println("========================");
    }
}
```

### 6. Criando o Cliente Demo

Exemplo demonstrando o uso completo do sistema:

```java
public class MementoPatternDemo {
    public static void main(String[] args) {
        System.out.println("=== MEMENTO PATTERN - EDITOR DE TEXTO ===\n");
        
        AdvancedTextEditor editor = new AdvancedTextEditor();
        
        // Demonstra√ß√£o b√°sica de inser√ß√£o e undo/redo
        System.out.println("1. OPERA√á√ïES B√ÅSICAS:");
        editor.insertText("Ol√°, ");
        System.out.println("Ap√≥s inserir 'Ol√°, ': " + editor.getContent());
        
        editor.insertText("mundo!");
        System.out.println("Ap√≥s inserir 'mundo!': " + editor.getContent());
        
        editor.insertText(" Como voc√™ est√°?");
        System.out.println("Ap√≥s inserir pergunta: " + editor.getContent());
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // Demonstra√ß√£o de undo
        System.out.println("2. TESTANDO UNDO:");
        editor.undo();
        System.out.println("Ap√≥s 1¬∫ undo: " + editor.getContent());
        
        editor.undo();
        System.out.println("Ap√≥s 2¬∫ undo: " + editor.getContent());
        
        editor.undo();
        System.out.println("Ap√≥s 3¬∫ undo: " + editor.getContent());
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // Demonstra√ß√£o de redo
        System.out.println("3. TESTANDO REDO:");
        editor.redo();
        System.out.println("Ap√≥s 1¬∫ redo: " + editor.getContent());
        
        editor.redo();
        System.out.println("Ap√≥s 2¬∫ redo: " + editor.getContent());
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // Demonstra√ß√£o de opera√ß√µes complexas
        System.out.println("4. OPERA√á√ïES COMPLEXAS:");
        editor.insertText("\nEste √© um teste do Memento Pattern.");
        editor.createSnapshot("Ap√≥s adicionar explica√ß√£o");
        
        editor.insertText("\nVamos testar replace all.");
        editor.createSnapshot("Antes do replace");
        
        // Replace all
        editor.replaceAll("teste", "exemplo");
        System.out.println("Ap√≥s replace 'teste' -> 'exemplo': " + editor.getContent());
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // Demonstra√ß√£o de delete
        System.out.println("5. TESTANDO DELETE:");
        editor.deleteText(10); // Deleta √∫ltimos 10 caracteres
        System.out.println("Ap√≥s deletar 10 caracteres: " + editor.getContent());
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // Demonstra√ß√£o de m√∫ltiplas opera√ß√µes e hist√≥rico
        System.out.println("6. TESTE DE HIST√ìRICO EXTENSO:");
        for (int i = 1; i <= 5; i++) {
            editor.insertText(" [Inser√ß√£o " + i + "]");
        }
        System.out.println("Ap√≥s 5 inser√ß√µes: " + editor.getContent());
        
        // Desfaz todas as inser√ß√µes
        System.out.println("\nDesfazendo todas as inser√ß√µes:");
        while (editor.canUndo()) {
            editor.undo();
            System.out.println("Undo -> Content: " + 
                (editor.getContent().length() > 50 ? 
                 editor.getContent().substring(0, 50) + "..." : 
                 editor.getContent()));
        }
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // Refaz algumas opera√ß√µes
        System.out.println("7. REFAZENDO OPERA√á√ïES:");
        for (int i = 0; i < 3 && editor.canRedo(); i++) {
            editor.redo();
            System.out.println("Redo " + (i+1) + " -> Content: " + 
                (editor.getContent().length() > 50 ? 
                 editor.getContent().substring(0, 50) + "..." : 
                 editor.getContent()));
        }
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // Estat√≠sticas finais
        System.out.println("8. ESTAT√çSTICAS FINAIS:");
        editor.showStats();
        
        System.out.println("\n" + "=".repeat(50) + "\n");
        
        // Teste de limpeza de hist√≥rico
        System.out.println("9. LIMPANDO HIST√ìRICO:");
        editor.clearHistory();
        editor.showStats();
        
        System.out.println("\n=== FIM DA DEMONSTRA√á√ÉO ===");
    }
}
```

### Sa√≠da do Programa

```
=== MEMENTO PATTERN - EDITOR DE TEXTO ===

History changed - Can Undo: false, Can Redo: false

1. OPERA√á√ïES B√ÅSICAS:
History changed - Can Undo: true, Can Redo: false
Ap√≥s inserir 'Ol√°, ': Ol√°, 
History changed - Can Undo: true, Can Redo: false
Ap√≥s inserir 'mundo!': Ol√°, mundo!
History changed - Can Undo: true, Can Redo: false
Ap√≥s inserir pergunta: Ol√°, mundo! Como voc√™ est√°?

==================================================

2. TESTANDO UNDO:
History changed - Can Undo: true, Can Redo: true
Ap√≥s 1¬∫ undo: Ol√°, mundo!
History changed - Can Undo: true, Can Redo: true
Ap√≥s 2¬∫ undo: Ol√°, 
History changed - Can Undo: false, Can Redo: true
Ap√≥s 3¬∫ undo: 

==================================================

3. TESTANDO REDO:
History changed - Can Undo: true, Can Redo: true
Ap√≥s 1¬∫ redo: Ol√°, 
History changed - Can Undo: true, Can Redo: true
Ap√≥s 2¬∫ redo: Ol√°, mundo!

==================================================

4. OPERA√á√ïES COMPLEXAS:
History changed - Can Undo: true, Can Redo: false
Creating snapshot: Ap√≥s adicionar explica√ß√£o
History changed - Can Undo: true, Can Redo: false
Creating snapshot: Antes do replace
History changed - Can Undo: true, Can Redo: false
Ap√≥s replace 'teste' -> 'exemplo': Ol√°, mundo!
Este √© um exemplo do Memento Pattern.
Vamos testar replace all.

==================================================

5. TESTANDO DELETE:
History changed - Can Undo: true, Can Redo: false
Ap√≥s deletar 10 caracteres: Ol√°, mundo!
Este √© um exemplo do Memento Pattern.
Vamos testar replace 

==================================================

6. TESTE DE HIST√ìRICO EXTENSO:
History changed - Can Undo: true, Can Redo: false
History changed - Can Undo: true, Can Redo: false
History changed - Can Undo: true, Can Redo: false
History changed - Can Undo: true, Can Redo: false
History changed - Can Undo: true, Can Redo: false
Ap√≥s 5 inser√ß√µes: Ol√°, mundo!
Este √© um exemplo do Memento Pattern.
Vamos testar replace  [Inser√ß√£o 1] [Inser√ß√£o 2] [Inser√ß√£o 3] [Inser√ß√£o 4] [Inser√ß√£o 5]

Desfazendo todas as inser√ß√µes:
History changed - Can Undo: true, Can Redo: true
Undo -> Content: Ol√°, mundo!
Este √© um exemplo do Memento Pattern...
History changed - Can Undo: true, Can Redo: true
Undo -> Content: Ol√°, mundo!
Este √© um exemplo do Memento Pattern...
History changed - Can Undo: true, Can Redo: true
Undo -> Content: Ol√°, mundo!
Este √© um exemplo do Memento Pattern...
History changed - Can Undo: true, Can Redo: true
Undo -> Content: Ol√°, mundo!
Este √© um exemplo do Memento Pattern...
History changed - Can Undo: true, Can Redo: true
Undo -> Content: Ol√°, mundo!
Este √© um exemplo do Memento Pattern...
History changed - Can Undo: true, Can Redo: true
Undo -> Content: Ol√°, mundo!
Este √© um exemplo do Memento Pattern...
History changed - Can Undo: true, Can Redo: true
Undo -> Content: Ol√°, mundo!
Este √© um exemplo do Memento Pattern...
History changed - Can Undo: true, Can Redo: true
Undo -> Content: Ol√°, mundo!
Este √© um exemplo do Memento Pattern...
History changed - Can Undo: true, Can Redo: true
Undo -> Content: Ol√°, mundo!
Este √© um exemplo do Memento Pattern...
History changed - Can Undo: false, Can Redo: true
Undo -> Content: 

==================================================

7. REFAZENDO OPERA√á√ïES:
History changed - Can Undo: true, Can Redo: true
Redo 1 -> Content: Ol√°, 
History changed - Can Undo: true, Can Redo: true
Redo 2 -> Content: Ol√°, mundo!
History changed - Can Undo: true, Can Redo: true
Redo 3 -> Content: Ol√°, mundo!
Este √© um exemplo do Memento Pattern...

==================================================

8. ESTAT√çSTICAS FINAIS:
=== EDITOR STATISTICS ===
Content length: 75
Cursor position: 75
Modified: true
Commands executed: 11
Undo stack size: 4
Redo stack size: 6
Can undo: true
Can redo: true
========================

==================================================

9. LIMPANDO HIST√ìRICO:
History changed - Can Undo: false, Can Redo: false
=== EDITOR STATISTICS ===
Content length: 75
Cursor position: 75
Modified: true
Commands executed: 0
Undo stack size: 1
Redo stack size: 0
Can undo: false
Can redo: false
========================

=== FIM DA DEMONSTRA√á√ÉO ===
```

### Explica√ß√£o do C√≥digo

1. **Memento Imut√°vel:** O `TextMemento` armazena o estado de forma imut√°vel e com acesso controlado.

2. **Originator Completo:** O `TextEditor` oferece opera√ß√µes completas de edi√ß√£o e m√©todos para criar/restaurar mementos.

3. **Caretaker Inteligente:** O `EditorHistory` gerencia pilhas de undo/redo com limite de tamanho e padr√£o Observer.

4. **Integra√ß√£o com Command Pattern:** Demonstra como Memento e Command podem trabalhar juntos para funcionalidades avan√ßadas.

5. **Opera√ß√µes Complexas:** Suporte a macros, replace all e opera√ß√µes compostas.

---

## Vantagens do Memento Pattern

1. **Preserva√ß√£o do Encapsulamento:** Permite capturar estado sem expor estrutura interna dos objetos.

2. **Simplicidade:** Interface simples para salvar e restaurar estados de objetos.

3. **Funcionalidades Avan√ßadas:** Base para implementar undo/redo, checkpoints e versionamento.

4. **Flexibilidade:** Pode ser usado com diferentes tipos de objetos e estados.

5. **Seguran√ßa:** Estados s√£o armazenados de forma imut√°vel, evitando modifica√ß√µes acidentais.

6. **Hist√≥rico Completo:** Permite manter hist√≥rico completo de mudan√ßas para auditoria.

---

## Desvantagens do Memento Pattern

1. **Uso de Mem√≥ria:** Pode consumir muita mem√≥ria se os estados forem grandes ou se houver muitos mementos.

2. **Performance:** Cria√ß√£o e restaura√ß√£o de mementos pode ser custosa para objetos complexos.

3. **Complexidade:** Adiciona complexidade ao c√≥digo, especialmente com m√∫ltiplos tipos de estado.

4. **Garbage Collection:** Grande n√∫mero de mementos pode impactar o garbage collector.

5. **Sincroniza√ß√£o:** Em ambientes multi-thread, pode requerer sincroniza√ß√£o adicional.

---

## Quando evitar o Memento Pattern?

- Quando o estado dos objetos √© muito grande e seria custoso de armazenar.
- Para aplica√ß√µes com restri√ß√µes severas de mem√≥ria.
- Quando os objetos mudam de estado muito frequentemente.
- Se o custo de criar/restaurar mementos √© maior que o benef√≠cio.
- Para sistemas simples onde undo/redo n√£o √© necess√°rio.
- Quando apenas algumas propriedades espec√≠ficas precisam ser restauradas (considere usar State Pattern).

---

## Padr√µes Relacionados

- **Command Pattern:** Frequentemente usado junto com Memento para implementar undo/redo de comandos.
- **Prototype Pattern:** Ambos fazem c√≥pias de objetos, mas Prototype clona o objeto todo enquanto Memento captura apenas o estado.
- **State Pattern:** Ambos lidam com estados de objetos, mas State muda comportamento enquanto Memento preserva estados.
- **Observer Pattern:** Pode ser usado para notificar sobre mudan√ßas no hist√≥rico de mementos.

---

## Conclus√£o

O **Memento Pattern** √© essencial para aplica√ß√µes que precisam de funcionalidades de undo/redo, versionamento ou backup de estado. Ele oferece uma forma elegante de capturar e restaurar estados de objetos sem violar o encapsulamento, proporcionando flexibilidade e controle sobre o hist√≥rico de mudan√ßas.

A chave para o sucesso na implementa√ß√£o do Memento Pattern est√° em balancear funcionalidade com performance, gerenciando adequadamente o uso de mem√≥ria e considerando a frequ√™ncia de cria√ß√£o de mementos. Quando bem implementado, o padr√£o pode significativamente melhorar a experi√™ncia do usu√°rio e a robustez da aplica√ß√£o.

Seja para implementar editores de texto, aplica√ß√µes de design gr√°fico, jogos com sistema de save/load, ou qualquer sistema que requer revers√£o de opera√ß√µes, o Memento Pattern oferece uma base s√≥lida e confi√°vel para gerenciamento de estado.

---

Gostou deste post? Continue acompanhando para mais conte√∫dos sobre padr√µes de design e desenvolvimento em **Java**!
---

**üîó Reposit√≥rio de Exemplos**

Aqui o link para nosso laborat√≥rio: [https://github.com/Nosbielc/nosbielc-dev-demos](https://github.com/Nosbielc/nosbielc-dev-demos)