---
title: "Strategy Pattern em Java: Implementando Algoritmos Intercambi√°veis"
description: "Aprenda como implementar o Strategy Pattern em Java para criar algoritmos flex√≠veis e intercambi√°veis. Descubra como este padr√£o comportamental pode melhorar a manutenibilidade do seu c√≥digo."
date: Jan 09 2025
---

## Introdu√ß√£o

O **Strategy Pattern** (Padr√£o Estrat√©gia) √© um padr√£o de design comportamental que define uma fam√≠lia de algoritmos, encapsula cada um deles e os torna intercambi√°veis. Este padr√£o permite que o algoritmo varie independentemente dos clientes que o utilizam, promovendo flexibilidade e reutiliza√ß√£o de c√≥digo.

Neste post, exploraremos o conceito do Strategy Pattern, suas vantagens e como implement√°-lo em Java com exemplos pr√°ticos.

---

## O que √© o Strategy Pattern?

O Strategy Pattern resolve o problema de ter m√∫ltiplas maneiras de executar uma tarefa, permitindo que voc√™ escolha o algoritmo apropriado em tempo de execu√ß√£o. Em vez de usar condicionais complexas (if/else ou switch), o padr√£o encapsula cada algoritmo em classes separadas.

**Principais componentes:**

1. **Strategy (Estrat√©gia):** Interface que define o contrato comum para todos os algoritmos.
2. **ConcreteStrategy (Estrat√©gia Concreta):** Implementa√ß√µes espec√≠ficas dos algoritmos.
3. **Context (Contexto):** Classe que utiliza uma estrat√©gia e pode alter√°-la conforme necess√°rio.

---

## Quando usar o Strategy Pattern?

- Quando voc√™ tem m√∫ltiplas maneiras de realizar uma tarefa.
- Para evitar condicionais complexas que escolhem entre diferentes algoritmos.
- Quando voc√™ quer adicionar novos algoritmos sem modificar o c√≥digo existente.
- Para promover o princ√≠pio Aberto/Fechado (Open/Closed Principle).

---

## Exemplo Pr√°tico em Java

Vamos implementar um sistema de c√°lculo de desconto para um e-commerce, onde diferentes tipos de clientes recebem descontos distintos.

---

#### 1. Criando a Interface Strategy

A interface define o contrato que todas as estrat√©gias de desconto devem implementar:

```java
public interface DiscountStrategy {
    double calculateDiscount(double originalPrice);
    String getDiscountDescription();
}
```

#### 2. Implementando as Estrat√©gias Concretas

**Estrat√©gia para Cliente Regular:**

```java
public class RegularCustomerDiscount implements DiscountStrategy {
    
    @Override
    public double calculateDiscount(double originalPrice) {
        return originalPrice * 0.05; // 5% de desconto
    }
    
    @Override
    public String getDiscountDescription() {
        return "Desconto Cliente Regular (5%)";
    }
}
```

**Estrat√©gia para Cliente Premium:**

```java
public class PremiumCustomerDiscount implements DiscountStrategy {
    
    @Override
    public double calculateDiscount(double originalPrice) {
        return originalPrice * 0.15; // 15% de desconto
    }
    
    @Override
    public String getDiscountDescription() {
        return "Desconto Cliente Premium (15%)";
    }
}
```

**Estrat√©gia para Cliente VIP:**

```java
public class VipCustomerDiscount implements DiscountStrategy {
    
    @Override
    public double calculateDiscount(double originalPrice) {
        return originalPrice * 0.25; // 25% de desconto
    }
    
    @Override
    public String getDiscountDescription() {
        return "Desconto Cliente VIP (25%)";
    }
}
```

---

#### 3. Criando a Classe Context

A classe **ShoppingCart** atua como contexto, utilizando as estrat√©gias de desconto:

```java
public class ShoppingCart {
    private DiscountStrategy discountStrategy;
    
    public ShoppingCart(DiscountStrategy discountStrategy) {
        this.discountStrategy = discountStrategy;
    }
    
    public void setDiscountStrategy(DiscountStrategy discountStrategy) {
        this.discountStrategy = discountStrategy;
    }
    
    public double calculateTotalPrice(double originalPrice) {
        double discount = discountStrategy.calculateDiscount(originalPrice);
        double finalPrice = originalPrice - discount;
        
        System.out.println("Pre√ßo original: R$ " + String.format("%.2f", originalPrice));
        System.out.println("Estrat√©gia aplicada: " + discountStrategy.getDiscountDescription());
        System.out.println("Desconto: R$ " + String.format("%.2f", discount));
        System.out.println("Pre√ßo final: R$ " + String.format("%.2f", finalPrice));
        System.out.println("---");
        
        return finalPrice;
    }
}
```

---

#### 4. Criando o Cliente

Demonstramos como usar o Strategy Pattern em diferentes cen√°rios:

```java
public class StrategyPatternDemo {
    public static void main(String[] args) {
        double originalPrice = 100.0;
        
        // Cliente Regular
        ShoppingCart cart = new ShoppingCart(new RegularCustomerDiscount());
        cart.calculateTotalPrice(originalPrice);
        
        // Mudando para Cliente Premium
        cart.setDiscountStrategy(new PremiumCustomerDiscount());
        cart.calculateTotalPrice(originalPrice);
        
        // Mudando para Cliente VIP
        cart.setDiscountStrategy(new VipCustomerDiscount());
        cart.calculateTotalPrice(originalPrice);
        
        // Demonstrando flexibilidade - criando carrinho espec√≠fico
        ShoppingCart vipCart = new ShoppingCart(new VipCustomerDiscount());
        vipCart.calculateTotalPrice(200.0);
    }
}
```

---

### Sa√≠da do Programa

Ao executar o c√≥digo acima, voc√™ ver√° a seguinte sa√≠da:

```text
Pre√ßo original: R$ 100,00
Estrat√©gia aplicada: Desconto Cliente Regular (5%)
Desconto: R$ 5,00
Pre√ßo final: R$ 95,00
---
Pre√ßo original: R$ 100,00
Estrat√©gia aplicada: Desconto Cliente Premium (15%)
Desconto: R$ 15,00
Pre√ßo final: R$ 85,00
---
Pre√ßo original: R$ 100,00
Estrat√©gia aplicada: Desconto Cliente VIP (25%)
Desconto: R$ 25,00
Pre√ßo final: R$ 75,00
---
Pre√ßo original: R$ 200,00
Estrat√©gia aplicada: Desconto Cliente VIP (25%)
Desconto: R$ 50,00
Pre√ßo final: R$ 150,00
---
```

---

### Explica√ß√£o do C√≥digo

1. **Interface DiscountStrategy:** Define o contrato comum para todos os algoritmos de desconto.

2. **Estrat√©gias Concretas:** Cada classe implementa uma pol√≠tica de desconto espec√≠fica (Regular, Premium, VIP).

3. **Classe ShoppingCart:** Atua como contexto, mantendo uma refer√™ncia para a estrat√©gia atual e delegando os c√°lculos para ela.

4. **Flexibilidade:** O algoritmo pode ser trocado em tempo de execu√ß√£o usando o m√©todo `setDiscountStrategy()`.

---

### Vantagens e Desvantagens

**Vantagens:**

- **Flexibilidade:** Algoritmos podem ser trocados facilmente em tempo de execu√ß√£o.
- **Extensibilidade:** Novas estrat√©gias podem ser adicionadas sem modificar c√≥digo existente.
- **Manutenibilidade:** Cada algoritmo fica isolado em sua pr√≥pria classe.
- **Testabilidade:** Cada estrat√©gia pode ser testada independentemente.
- **Princ√≠pio Aberto/Fechado:** Aberto para extens√£o, fechado para modifica√ß√£o.

**Desvantagens:**

- **Prolifera√ß√£o de Classes:** Pode aumentar o n√∫mero de classes no sistema.
- **Complexidade Inicial:** Para casos simples, pode ser excessivo.
- **Conhecimento das Estrat√©gias:** O cliente precisa conhecer as diferentes estrat√©gias dispon√≠veis.

---

### Varia√ß√µes do Strategy Pattern

**Strategy com Enum:**

```java
public enum DiscountType {
    REGULAR(0.05),
    PREMIUM(0.15),
    VIP(0.25);
    
    private final double discountRate;
    
    DiscountType(double discountRate) {
        this.discountRate = discountRate;
    }
    
    public double calculateDiscount(double originalPrice) {
        return originalPrice * discountRate;
    }
}
```

**Strategy com Express√µes Lambda (Java 8+):**

```java
// Definindo estrat√©gias como fun√ß√µes
Function<Double, Double> regularDiscount = price -> price * 0.05;
Function<Double, Double> premiumDiscount = price -> price * 0.15;
Function<Double, Double> vipDiscount = price -> price * 0.25;

// Uso das estrat√©gias
double price = 100.0;
double discountRegular = regularDiscount.apply(price);
```

---

### Quando evitar o Strategy Pattern?

- Para casos muito simples com apenas 2-3 op√ß√µes, uma estrutura if/else pode ser suficiente.
- Quando os algoritmos raramente mudam ou s√£o adicionados.
- Se a performance for cr√≠tica e o overhead de chamadas polim√≥rficas for significativo.

---

### Conclus√£o

O **Strategy Pattern** √© uma solu√ß√£o elegante para cen√°rios onde voc√™ precisa escolher entre diferentes algoritmos em tempo de execu√ß√£o. Ele promove c√≥digo limpo, flex√≠vel e facilmente extens√≠vel, seguindo princ√≠pios s√≥lidos de design orientado a objetos.

Este padr√£o √© especialmente √∫til em Java, onde pode ser implementado de forma clara e eficiente. Se voc√™ trabalha com sistemas que precisam de flexibilidade algor√≠tmica, o Strategy Pattern √© uma ferramenta indispens√°vel no seu arsenal de design patterns.

---

Gostou deste post? Continue acompanhando para mais conte√∫dos sobre padr√µes de design e desenvolvimento em **Java**!
---

**üîó Reposit√≥rio de Exemplos**

Aqui o link para nosso laborat√≥rio: [https://github.com/Nosbielc/nosbielc-dev-demos](https://github.com/Nosbielc/nosbielc-dev-demos)