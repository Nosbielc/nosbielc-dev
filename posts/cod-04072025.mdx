---
title: "Decorator Pattern em Java: Adicionando Funcionalidades Dinamicamente"
description: "Aprenda como implementar o Decorator Pattern em Java para adicionar responsabilidades a objetos de forma din√¢mica e flex√≠vel. Descubra como este padr√£o estrutural promove extensibilidade sem modificar c√≥digo existente."
date: Jul 04 2025
---

## Introdu√ß√£o

O **Decorator Pattern** (Padr√£o Decorador) √© um padr√£o de design estrutural que permite adicionar novos comportamentos a objetos colocando-os dentro de objetos wrapper especiais que cont√™m os comportamentos. Este padr√£o oferece uma alternativa flex√≠vel √† heran√ßa para estender funcionalidades, seguindo o princ√≠pio Aberto/Fechado.

Neste post, exploraremos o conceito do Decorator Pattern, suas vantagens e como implement√°-lo em Java com exemplos pr√°ticos de um sistema de cafeteria onde diferentes complementos podem ser adicionados √†s bebidas.

---

## O que √© o Decorator Pattern?

O Decorator Pattern resolve o problema de adicionar funcionalidades a objetos sem alterar sua estrutura ou criar uma explos√£o de subclasses. Em vez de usar heran√ßa est√°tica, o padr√£o usa composi√ß√£o para "envolver" objetos com novos comportamentos de forma din√¢mica.

**Principais componentes:**

1. **Component (Componente):** Interface comum que define as opera√ß√µes que podem ser alteradas dinamicamente pelos decoradores.
2. **ConcreteComponent (Componente Concreto):** Classe que define um objeto ao qual funcionalidades adicionais podem ser anexadas.
3. **Decorator (Decorador):** Classe abstrata que mant√©m uma refer√™ncia ao componente e define a interface conforme a interface do componente.
4. **ConcreteDecorator (Decorador Concreto):** Adiciona responsabilidades ao componente.

---

## Quando usar o Decorator Pattern?

- Quando voc√™ quer adicionar responsabilidades a objetos dinamicamente sem afetar outros objetos.
- Para evitar a explos√£o de subclasses que resultaria da combina√ß√£o de m√∫ltiplas funcionalidades.
- Quando a extens√£o por heran√ßa √© impratic√°vel ou gera muitas combina√ß√µes.
- Para implementar funcionalidades que podem ser combinadas de v√°rias maneiras.
- Quando voc√™ quer que as responsabilidades possam ser adicionadas e removidas em tempo de execu√ß√£o.

---

## Exemplo Pr√°tico em Java

Vamos implementar um sistema de cafeteria onde diferentes complementos (leite, a√ß√∫car, chocolate, etc.) podem ser adicionados √†s bebidas de forma din√¢mica.

---

#### 1. Criando a Interface Component

A interface define o contrato comum para todas as bebidas:

```java
public interface Beverage {
    String getDescription();
    double getCost();
}
```

#### 2. Implementando os Componentes Concretos

**Caf√© Simples:**

```java
public class SimpleCoffee implements Beverage {
    
    @Override
    public String getDescription() {
        return "Caf√© simples";
    }
    
    @Override
    public double getCost() {
        return 2.00;
    }
}
```

**Espresso:**

```java
public class Espresso implements Beverage {
    
    @Override
    public String getDescription() {
        return "Espresso";
    }
    
    @Override
    public double getCost() {
        return 3.50;
    }
}
```

**Cappuccino:**

```java
public class Cappuccino implements Beverage {
    
    @Override
    public String getDescription() {
        return "Cappuccino";
    }
    
    @Override
    public double getCost() {
        return 4.00;
    }
}
```

---

#### 3. Criando a Classe Decorator Abstrata

A classe decorator mant√©m uma refer√™ncia ao componente e implementa a mesma interface:

```java
public abstract class BeverageDecorator implements Beverage {
    protected Beverage beverage;
    
    public BeverageDecorator(Beverage beverage) {
        this.beverage = beverage;
    }
    
    @Override
    public String getDescription() {
        return beverage.getDescription();
    }
    
    @Override
    public double getCost() {
        return beverage.getCost();
    }
}
```

---

#### 4. Implementando os Decoradores Concretos

**Decorador de Leite:**

```java
public class MilkDecorator extends BeverageDecorator {
    
    public MilkDecorator(Beverage beverage) {
        super(beverage);
    }
    
    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Leite";
    }
    
    @Override
    public double getCost() {
        return beverage.getCost() + 0.50;
    }
}
```

**Decorador de A√ß√∫car:**

```java
public class SugarDecorator extends BeverageDecorator {
    
    public SugarDecorator(Beverage beverage) {
        super(beverage);
    }
    
    @Override
    public String getDescription() {
        return beverage.getDescription() + ", A√ß√∫car";
    }
    
    @Override
    public double getCost() {
        return beverage.getCost() + 0.25;
    }
}
```

**Decorador de Chocolate:**

```java
public class ChocolateDecorator extends BeverageDecorator {
    
    public ChocolateDecorator(Beverage beverage) {
        super(beverage);
    }
    
    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Chocolate";
    }
    
    @Override
    public double getCost() {
        return beverage.getCost() + 1.00;
    }
}
```

**Decorador de Chantilly:**

```java
public class WhipCreamDecorator extends BeverageDecorator {
    
    public WhipCreamDecorator(Beverage beverage) {
        super(beverage);
    }
    
    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Chantilly";
    }
    
    @Override
    public double getCost() {
        return beverage.getCost() + 0.75;
    }
}
```

**Decorador de Canela:**

```java
public class CinnamonDecorator extends BeverageDecorator {
    
    public CinnamonDecorator(Beverage beverage) {
        super(beverage);
    }
    
    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Canela";
    }
    
    @Override
    public double getCost() {
        return beverage.getCost() + 0.30;
    }
}
```

---

#### 5. Criando o Cliente

Demonstramos como usar o Decorator Pattern para criar diferentes combina√ß√µes de bebidas:

```java
public class CoffeeShopDemo {
    
    public static void main(String[] args) {
        System.out.println("=== Bem-vindo √† Cafeteria! ===\n");
        
        // Caf√© simples sem adicionais
        Beverage simpleCoffee = new SimpleCoffee();
        printBeverage(simpleCoffee);
        
        // Caf√© simples com leite
        Beverage coffeeWithMilk = new MilkDecorator(new SimpleCoffee());
        printBeverage(coffeeWithMilk);
        
        // Espresso com m√∫ltiplos complementos
        Beverage fancyEspresso = new ChocolateDecorator(
            new WhipCreamDecorator(
                new MilkDecorator(
                    new SugarDecorator(
                        new Espresso()
                    )
                )
            )
        );
        printBeverage(fancyEspresso);
        
        // Cappuccino com canela e a√ß√∫car
        Beverage spicedCappuccino = new CinnamonDecorator(
            new SugarDecorator(
                new Cappuccino()
            )
        );
        printBeverage(spicedCappuccino);
        
        // Demonstrando flexibilidade - adicionando decoradores dinamicamente
        System.out.println("=== Personalizando bebida passo a passo ===");
        Beverage customBeverage = new SimpleCoffee();
        System.out.println("Base: " + customBeverage.getDescription() + 
                          " - R$ " + String.format("%.2f", customBeverage.getCost()));
        
        customBeverage = new MilkDecorator(customBeverage);
        System.out.println("+ Leite: " + customBeverage.getDescription() + 
                          " - R$ " + String.format("%.2f", customBeverage.getCost()));
        
        customBeverage = new ChocolateDecorator(customBeverage);
        System.out.println("+ Chocolate: " + customBeverage.getDescription() + 
                          " - R$ " + String.format("%.2f", customBeverage.getCost()));
        
        customBeverage = new WhipCreamDecorator(customBeverage);
        System.out.println("+ Chantilly: " + customBeverage.getDescription() + 
                          " - R$ " + String.format("%.2f", customBeverage.getCost()));
        
        System.out.println("\n=== Pedido finalizado! ===");
    }
    
    private static void printBeverage(Beverage beverage) {
        System.out.println("Pedido: " + beverage.getDescription());
        System.out.println("Pre√ßo: R$ " + String.format("%.2f", beverage.getCost()));
        System.out.println("---");
    }
}
```

---

### Sa√≠da do Programa

Ao executar o c√≥digo acima, voc√™ ver√° a seguinte sa√≠da:

```text
=== Bem-vindo √† Cafeteria! ===

Pedido: Caf√© simples
Pre√ßo: R$ 2,00
---
Pedido: Caf√© simples, Leite
Pre√ßo: R$ 2,50
---
Pedido: Espresso, A√ß√∫car, Leite, Chantilly, Chocolate
Pre√ßo: R$ 5,50
---
Pedido: Cappuccino, A√ß√∫car, Canela
Pre√ßo: R$ 4,55
---
=== Personalizando bebida passo a passo ===
Base: Caf√© simples - R$ 2,00
+ Leite: Caf√© simples, Leite - R$ 2,50
+ Chocolate: Caf√© simples, Leite, Chocolate - R$ 3,50
+ Chantilly: Caf√© simples, Leite, Chocolate, Chantilly - R$ 4,25

=== Pedido finalizado! ===
```

---

### Explica√ß√£o do C√≥digo

1. **Interface Beverage:** Define o contrato comum que todos os componentes e decoradores devem implementar.

2. **Componentes Concretos:** `SimpleCoffee`, `Espresso` e `Cappuccino` s√£o as implementa√ß√µes base das bebidas.

3. **BeverageDecorator:** Classe abstrata que implementa a interface `Beverage` e mant√©m uma refer√™ncia ao objeto que est√° sendo decorado.

4. **Decoradores Concretos:** Cada decorador adiciona uma funcionalidade espec√≠fica, modificando a descri√ß√£o e o custo da bebida.

5. **Composi√ß√£o Din√¢mica:** Os decoradores podem ser combinados de qualquer forma, permitindo milhares de combina√ß√µes diferentes.

6. **Transpar√™ncia:** O cliente trata objetos decorados da mesma forma que objetos simples.

---

### Vantagens e Desvantagens

**Vantagens:**

- **Flexibilidade:** Comportamentos podem ser adicionados e removidos em tempo de execu√ß√£o.
- **Composi√ß√£o vs Heran√ßa:** Evita a explos√£o de subclasses que resultaria de todas as combina√ß√µes poss√≠veis.
- **Princ√≠pio da Responsabilidade √önica:** Cada decorador tem uma responsabilidade espec√≠fica.
- **Princ√≠pio Aberto/Fechado:** Novas funcionalidades podem ser adicionadas sem modificar c√≥digo existente.
- **Combina√ß√µes Infinitas:** Decoradores podem ser combinados de qualquer forma.

**Desvantagens:**

- **Complexidade:** Pode ser dif√≠cil de entender e debugar com muitos decoradores aninhados.
- **Identidade de Objetos:** Um objeto decorado n√£o √© id√™ntico ao objeto original.
- **Prolifera√ß√£o de Classes:** Muitos decoradores pequenos podem poluir o design.
- **Performance:** M√∫ltiplas camadas de decora√ß√£o podem impactar a performance.

---

### Varia√ß√µes do Decorator Pattern

**Decorator com Builder Pattern:**

```java
public class BeverageBuilder {
    private Beverage beverage;
    
    public BeverageBuilder(Beverage baseBeverage) {
        this.beverage = baseBeverage;
    }
    
    public BeverageBuilder addMilk() {
        this.beverage = new MilkDecorator(beverage);
        return this;
    }
    
    public BeverageBuilder addSugar() {
        this.beverage = new SugarDecorator(beverage);
        return this;
    }
    
    public BeverageBuilder addChocolate() {
        this.beverage = new ChocolateDecorator(beverage);
        return this;
    }
    
    public Beverage build() {
        return beverage;
    }
}

// Uso
Beverage customBeverage = new BeverageBuilder(new Espresso())
    .addMilk()
    .addSugar()
    .addChocolate()
    .build();
```

**Decorator com Annotations (usando reflex√£o):**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface AddOn {
    String name();
    double cost();
}

@AddOn(name = "Leite", cost = 0.50)
public class AutoMilkDecorator extends BeverageDecorator {
    // Implementa√ß√£o usando reflex√£o para ler a annotation
}
```

---

### Quando evitar o Decorator Pattern?

- Quando voc√™ tem apenas uma ou duas varia√ß√µes simples - heran√ßa pode ser mais simples.
- Se a ordem dos decoradores importa muito e pode causar confus√£o.
- Quando a performance √© cr√≠tica e o overhead de m√∫ltiplas camadas √© inaceit√°vel.
- Para sistemas onde a identidade do objeto √© crucial.

---

### Conclus√£o

O **Decorator Pattern** √© uma solu√ß√£o poderosa para adicionar funcionalidades a objetos de forma din√¢mica e flex√≠vel. Ele promove extensibilidade, reutiliza√ß√£o de c√≥digo e segue princ√≠pios s√≥lidos de design orientado a objetos, especialmente o princ√≠pio Aberto/Fechado.

Este padr√£o √© amplamente usado em Java, desde as classes de I/O (`BufferedReader`, `FileReader`) at√© frameworks web e sistemas de UI. Se voc√™ trabalha com sistemas que precisam de funcionalidades combin√°vels e extens√≠veis, o Decorator Pattern √© uma ferramenta essencial no seu arsenal de design patterns.

---

Gostou deste post? Continue acompanhando para mais conte√∫dos sobre padr√µes de design e desenvolvimento em **Java**!
---

**üîó Reposit√≥rio de Exemplos**

Aqui o link para nosso laborat√≥rio: [https://github.com/Nosbielc/nosbielc-dev-demos](https://github.com/Nosbielc/nosbielc-dev-demos)