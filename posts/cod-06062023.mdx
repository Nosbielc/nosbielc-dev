---
title: "Explorando o Prototype Pattern com Java: Uma Ferramenta Poderosa de Design de Software"
description: "Neste post, mergulharemos profundamente no Prototype Pattern, um padr√£o de design que oferece um m√©todo eficiente para copiar objetos existentes, evitando o custo de criar novos do zero. Faremos isso com a ajuda de exemplos pr√°ticos em Java."
date: Jun 06 2023
---

No mundo do design de software, os padr√µes de design s√£o solu√ß√µes comprovadas para problemas comuns de projeto. Hoje, vamos explorar o Prototype Pattern, um padr√£o de design creacional que √© usado quando o tipo de objetos a criar √© determinado por uma inst√¢ncia protot√≠pica, que √© copiada para produzir novos objetos.

Vamos come√ßar criando uma interface chamada 'Prototype' que ser√° implementada por todas as classes que precisam ser copiadas.

```java
public interface Prototype {
    Prototype clone();
}
```

Agora, vamos criar uma classe concreta que implementa a interface _Prototype_.

```java
public class ConcretePrototype implements Prototype {
    private String field;

    public ConcretePrototype(String field) {
        this.field = field;
    }

    public ConcretePrototype(ConcretePrototype prototype) {
        if (prototype != null) {
            this.field = prototype.field;
        }
    }

    @Override
    public Prototype clone() {
        return new ConcretePrototype(this);
    }

    @Override
    public String toString() {
        return field;
    }
}
```

Na classe _ConcretePrototype_, temos um construtor de c√≥pia que cria um novo objeto _ConcretePrototype_ a partir de um existente. O m√©todo clone() retorna um novo _ConcretePrototype_ que √© uma c√≥pia do objeto atual.

Vamos ver como usamos o Prototype Pattern na pr√°tica.

```java
public class PrototypeDemo {
    public static void main(String[] args) {
        ConcretePrototype original = new ConcretePrototype("Original");
        System.out.println("Original: " + original);

        ConcretePrototype cloned = (ConcretePrototype) original.clone();
        System.out.println("Cloned: " + cloned);
    }
}
```

Quando voc√™ executa _PrototypeDemo_, ele cria uma c√≥pia de 'original' chamada 'cloned'. Ambos os objetos s√£o independentes. As altera√ß√µes feitas em um objeto n√£o afetar√£o o outro.

O Prototype Pattern √© √∫til quando a inicializa√ß√£o de um objeto √© cara, e voc√™ precisa criar v√°rias inst√¢ncias que s√£o semelhantes, ou quando as classes a instanciar s√£o especificadas em tempo de execu√ß√£o.

Lembre-se, padr√µes de design s√£o uma ferramenta valiosa, mas n√£o s√£o uma solu√ß√£o para todos os problemas. Eles devem ser aplicados quando apropriado e entender os conceitos subjacentes √© crucial para aproveit√°-los ao m√°ximo.

Agora que cobrimos o b√°sico, vamos adicionar complexidade ao nosso exemplo com uma classe que cont√©m v√°rios campos. Suponha que temos uma classe Person com campos _name_, _age_ e _address_.

```java
public class Person implements Prototype {
    private String name;
    private int age;
    private Address address;

    public Person(String name, int age, Address address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }

    public Person(Person person) {
        if (person != null) {
            this.name = person.name;
            this.age = person.age;
            this.address = (Address) person.address.clone();
        }
    }

    @Override
    public Prototype clone() {
        return new Person(this);
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", address=" + address +
                '}';
    }
}
```

Aqui, _Address_ √© tamb√©m uma classe clon√°vel:

```java
public class Address implements Prototype {
    private String street;
    private String city;
    private String country;

    public Address(String street, String city, String country) {
        this.street = street;
        this.city = city;
        this.country = country;
    }

    public Address(Address address) {
        if (address != null) {
            this.street = address.street;
            this.city = address.city;
            this.country = address.country;
        }
    }

    @Override
    public Prototype clone() {
        return new Address(this);
    }

    @Override
    public String toString() {
        return "Address{" +
                "street='" + street + '\'' +
                ", city='" + city + '\'' +
                ", country='" + country + '\'' +
                '}';
    }
}
```

No exemplo acima, para criar uma c√≥pia profunda de _Person_, precisamos tamb√©m clonar o campo _address_.

Vamos ver um exemplo de como usar isso:

```java
public class PrototypeDemo {
    public static void main(String[] args) {
        Person original = new Person("John", 25, new Address("Street 1", "City 1", "Country 1"));
        System.out.println("Original: " + original);

        Person cloned = (Person) original.clone();
        System.out.println("Cloned: " + cloned);
    }
}
```

Neste caso, _original_ e _cloned_ s√£o duas inst√¢ncias diferentes com os mesmos valores para seus campos. No entanto, eles s√£o completamente independentes um do outro. Altera√ß√µes feitas em _cloned_ n√£o afetar√£o _original_, e vice-versa.

---

**Conclus√£o**

Para concluir, o Prototype Pattern √© uma maneira poderosa e eficiente de copiar objetos complexos. Ele permite que voc√™ fa√ßa c√≥pias profundas de objetos, preservando a independ√™ncia entre eles, sem a necessidade de conhecer a classe concreta do objeto que est√° sendo copiado. Lembre-se sempre de considerar o uso de padr√µes de design de software em suas solu√ß√µes para melhorar a estrutura e efici√™ncia de seu c√≥digo.
---

**üîó Reposit√≥rio de Exemplos**

Aqui o link para nosso laborat√≥rio: [https://github.com/Nosbielc/nosbielc-dev-demos](https://github.com/Nosbielc/nosbielc-dev-demos)