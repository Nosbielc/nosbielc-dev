---
title: "Template Method Pattern em Java: Definindo o Esqueleto de Algoritmos"
description: "Aprenda como implementar o Template Method Pattern em Java para criar algoritmos flex√≠veis com estrutura reutiliz√°vel. Descubra como este padr√£o comportamental promove reutiliza√ß√£o de c√≥digo e extensibilidade."
date: Jul 02 2025
---

## Introdu√ß√£o

O **Template Method Pattern** (Padr√£o M√©todo Template) √© um padr√£o de design comportamental que define o esqueleto de um algoritmo em uma opera√ß√£o, adiando alguns passos para subclasses. Este padr√£o permite que as subclasses redefinam certas etapas de um algoritmo sem alterar sua estrutura geral, promovendo reutiliza√ß√£o de c√≥digo e consist√™ncia.

Neste post, exploraremos o conceito do Template Method Pattern, suas vantagens e como implement√°-lo em Java com exemplos pr√°ticos de um sistema de processamento de dados.

---

## O que √© o Template Method Pattern?

O Template Method Pattern resolve o problema de ter algoritmos com estrutura similar, mas com implementa√ß√µes espec√≠ficas em certas etapas. Em vez de duplicar c√≥digo, o padr√£o define uma estrutura comum e permite que subclasses personalizem apenas as partes necess√°rias.

**Principais componentes:**

1. **Abstract Class (Classe Abstrata):** Define o m√©todo template e os m√©todos abstratos que ser√£o implementados pelas subclasses.
2. **Template Method (M√©todo Template):** Define o esqueleto do algoritmo, chamando os m√©todos abstratos na ordem correta.
3. **Concrete Methods (M√©todos Concretos):** Implementa√ß√µes padr√£o que podem ser reutilizadas ou sobrescritas.
4. **Hook Methods (M√©todos Gancho):** M√©todos opcionais que subclasses podem sobrescrever para personalizar o comportamento.

---

## Quando usar o Template Method Pattern?

- Quando voc√™ tem m√∫ltiplos algoritmos com estrutura similar, mas passos espec√≠ficos diferentes.
- Para evitar duplica√ß√£o de c√≥digo em algoritmos relacionados.
- Quando voc√™ quer garantir que certas etapas sejam executadas em uma ordem espec√≠fica.
- Para permitir extensibilidade controlada - subclasses podem personalizar apenas partes espec√≠ficas.
- Para implementar o princ√≠pio Hollywood: "N√£o nos chame, n√≥s chamaremos voc√™".

---

## Exemplo Pr√°tico em Java

Vamos implementar um sistema de processamento de relat√≥rios onde diferentes tipos de relat√≥rios seguem o mesmo fluxo b√°sico, mas com implementa√ß√µes espec√≠ficas para cada tipo.

---

#### 1. Criando a Classe Abstrata

A classe abstrata define o m√©todo template e os m√©todos que devem ser implementados pelas subclasses:

```java
public abstract class DataProcessor {
    
    // Template Method - define o algoritmo principal
    public final void processData() {
        System.out.println("=== Iniciando processamento de dados ===");
        
        loadData();
        validateData();
        processSpecificData();
        
        if (shouldSaveToDatabase()) {
            saveToDatabase();
        }
        
        generateReport();
        notifyCompletion();
        
        System.out.println("=== Processamento conclu√≠do ===\n");
    }
    
    // M√©todos abstratos - devem ser implementados pelas subclasses
    protected abstract void loadData();
    protected abstract void validateData();
    protected abstract void processSpecificData();
    protected abstract void generateReport();
    
    // Hook method - pode ser sobrescrito opcionalmente
    protected boolean shouldSaveToDatabase() {
        return true; // comportamento padr√£o
    }
    
    // M√©todos concretos - implementa√ß√£o padr√£o reutiliz√°vel
    protected void saveToDatabase() {
        System.out.println("Salvando dados processados no banco de dados...");
    }
    
    protected void notifyCompletion() {
        System.out.println("Notifica√ß√£o de conclus√£o enviada aos usu√°rios.");
    }
}
```

---

#### 2. Implementando as Subclasses Concretas

**Processador de Vendas:**

```java
public class SalesDataProcessor extends DataProcessor {
    
    @Override
    protected void loadData() {
        System.out.println("Carregando dados de vendas do sistema CRM...");
        // Simula carregamento de dados de vendas
    }
    
    @Override
    protected void validateData() {
        System.out.println("Validando dados de vendas (valores, datas, vendedores)...");
        // Simula valida√ß√£o espec√≠fica para vendas
    }
    
    @Override
    protected void processSpecificData() {
        System.out.println("Calculando totais de vendas, comiss√µes e metas atingidas...");
        // Simula processamento espec√≠fico de vendas
    }
    
    @Override
    protected void generateReport() {
        System.out.println("Gerando relat√≥rio de vendas em formato PDF...");
        // Simula gera√ß√£o de relat√≥rio de vendas
    }
}
```

**Processador de Invent√°rio:**

```java
public class InventoryDataProcessor extends DataProcessor {
    
    @Override
    protected void loadData() {
        System.out.println("Carregando dados de invent√°rio do sistema de estoque...");
        // Simula carregamento de dados de invent√°rio
    }
    
    @Override
    protected void validateData() {
        System.out.println("Validando dados de invent√°rio (quantidades, pre√ßos, localiza√ß√£o)...");
        // Simula valida√ß√£o espec√≠fica para invent√°rio
    }
    
    @Override
    protected void processSpecificData() {
        System.out.println("Calculando n√≠veis de estoque, itens em falta e reposi√ß√£o necess√°ria...");
        // Simula processamento espec√≠fico de invent√°rio
    }
    
    @Override
    protected void generateReport() {
        System.out.println("Gerando relat√≥rio de invent√°rio em formato Excel...");
        // Simula gera√ß√£o de relat√≥rio de invent√°rio
    }
    
    // Sobrescreve o hook method para invent√°rio cr√≠tico
    @Override
    protected boolean shouldSaveToDatabase() {
        System.out.println("Verificando se h√° itens cr√≠ticos no estoque...");
        return true; // sempre salva para invent√°rio
    }
}
```

**Processador de Relat√≥rio Financeiro (sem salvamento em BD):**

```java
public class FinancialDataProcessor extends DataProcessor {
    
    @Override
    protected void loadData() {
        System.out.println("Carregando dados financeiros do sistema cont√°bil...");
        // Simula carregamento de dados financeiros
    }
    
    @Override
    protected void validateData() {
        System.out.println("Validando dados financeiros (balan√ßos, fluxos de caixa)...");
        // Simula valida√ß√£o espec√≠fica para finan√ßas
    }
    
    @Override
    protected void processSpecificData() {
        System.out.println("Calculando indicadores financeiros e an√°lises de rentabilidade...");
        // Simula processamento espec√≠fico financeiro
    }
    
    @Override
    protected void generateReport() {
        System.out.println("Gerando relat√≥rio financeiro confidencial em formato seguro...");
        // Simula gera√ß√£o de relat√≥rio financeiro
    }
    
    // Hook method personalizado - relat√≥rios financeiros n√£o s√£o salvos no BD comum
    @Override
    protected boolean shouldSaveToDatabase() {
        System.out.println("Relat√≥rios financeiros s√£o confidenciais - n√£o salvando no BD comum.");
        return false;
    }
    
    // Sobrescreve m√©todo de notifica√ß√£o para relat√≥rios confidenciais
    @Override
    protected void notifyCompletion() {
        System.out.println("Notifica√ß√£o confidencial enviada apenas para a diretoria.");
    }
}
```

---

#### 3. Criando o Cliente

Demonstramos como usar o Template Method Pattern com diferentes processadores:

```java
public class TemplateMethodDemo {
    public static void main(String[] args) {
        
        // Processando dados de vendas
        DataProcessor salesProcessor = new SalesDataProcessor();
        salesProcessor.processData();
        
        // Processando dados de invent√°rio
        DataProcessor inventoryProcessor = new InventoryDataProcessor();
        inventoryProcessor.processData();
        
        // Processando dados financeiros
        DataProcessor financialProcessor = new FinancialDataProcessor();
        financialProcessor.processData();
        
        // Demonstrando polimorfismo
        System.out.println("=== Processamento em lote ===");
        DataProcessor[] processors = {
            new SalesDataProcessor(),
            new InventoryDataProcessor(),
            new FinancialDataProcessor()
        };
        
        for (DataProcessor processor : processors) {
            processor.processData();
        }
    }
}
```

---

### Sa√≠da do Programa

Ao executar o c√≥digo acima, voc√™ ver√° a seguinte sa√≠da:

```text
=== Iniciando processamento de dados ===
Carregando dados de vendas do sistema CRM...
Validando dados de vendas (valores, datas, vendedores)...
Calculando totais de vendas, comiss√µes e metas atingidas...
Salvando dados processados no banco de dados...
Gerando relat√≥rio de vendas em formato PDF...
Notifica√ß√£o de conclus√£o enviada aos usu√°rios.
=== Processamento conclu√≠do ===

=== Iniciando processamento de dados ===
Carregando dados de invent√°rio do sistema de estoque...
Validando dados de invent√°rio (quantidades, pre√ßos, localiza√ß√£o)...
Calculando n√≠veis de estoque, itens em falta e reposi√ß√£o necess√°ria...
Verificando se h√° itens cr√≠ticos no estoque...
Salvando dados processados no banco de dados...
Gerando relat√≥rio de invent√°rio em formato Excel...
Notifica√ß√£o de conclus√£o enviada aos usu√°rios.
=== Processamento conclu√≠do ===

=== Iniciando processamento de dados ===
Carregando dados financeiros do sistema cont√°bil...
Validando dados financeiros (balan√ßos, fluxos de caixa)...
Calculando indicadores financeiros e an√°lises de rentabilidade...
Relat√≥rios financeiros s√£o confidenciais - n√£o salvando no BD comum.
Gerando relat√≥rio financeiro confidencial em formato seguro...
Notifica√ß√£o confidencial enviada apenas para a diretoria.
=== Processamento conclu√≠do ===
```

---

### Explica√ß√£o do C√≥digo

1. **DataProcessor:** A classe abstrata define o template method `processData()` que estabelece a ordem das opera√ß√µes.

2. **Template Method:** O m√©todo `processData()` √© `final` para impedir que subclasses alterem a estrutura do algoritmo.

3. **M√©todos Abstratos:** `loadData()`, `validateData()`, `processSpecificData()` e `generateReport()` devem ser implementados pelas subclasses.

4. **Hook Methods:** `shouldSaveToDatabase()` √© um m√©todo gancho que pode ser sobrescrito opcionalmente.

5. **M√©todos Concretos:** `saveToDatabase()` e `notifyCompletion()` fornecem implementa√ß√µes padr√£o que podem ser reutilizadas.

6. **Polimorfismo:** O padr√£o funciona perfeitamente com polimorfismo, permitindo tratar diferentes processadores de forma uniforme.

---

### Vantagens e Desvantagens

**Vantagens:**

- **Reutiliza√ß√£o de C√≥digo:** Elimina duplica√ß√£o de c√≥digo comum entre algoritmos similares.
- **Controle de Estrutura:** Garante que o algoritmo siga uma sequ√™ncia espec√≠fica de passos.
- **Extensibilidade:** Novas varia√ß√µes podem ser criadas facilmente estendendo a classe base.
- **Princ√≠pio Hollywood:** A classe base controla quando chamar os m√©todos das subclasses.
- **Manutenibilidade:** Mudan√ßas na estrutura do algoritmo precisam ser feitas apenas na classe base.

**Desvantagens:**

- **Heran√ßa Obrigat√≥ria:** For√ßa o uso de heran√ßa, que pode ser limitante.
- **Viola√ß√£o do LSP:** Subclasses mal implementadas podem quebrar o comportamento esperado.
- **Debugging Complexo:** O fluxo de execu√ß√£o pode ser dif√≠cil de acompanhar.
- **Rigidez:** A estrutura do algoritmo √© fixa e n√£o pode ser facilmente alterada.

---

### Varia√ß√µes do Template Method Pattern

**Template Method com Enums:**

```java
public enum ProcessingStep {
    LOAD_DATA("Carregando dados..."),
    VALIDATE_DATA("Validando dados..."),
    PROCESS_DATA("Processando dados..."),
    GENERATE_REPORT("Gerando relat√≥rio...");
    
    private final String description;
    
    ProcessingStep(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}
```

**Template Method com Callbacks (Java 8+):**

```java
public class CallbackProcessor {
    
    public void processData(
            Runnable loadData,
            Runnable validateData,
            Runnable processData,
            Runnable generateReport) {
        
        System.out.println("=== Iniciando processamento ===");
        loadData.run();
        validateData.run();
        processData.run();
        generateReport.run();
        System.out.println("=== Processamento conclu√≠do ===");
    }
}
```

---

### Quando evitar o Template Method Pattern?

- Quando o algoritmo √© muito simples e n√£o justifica a complexidade da heran√ßa.
- Se voc√™ precisar de m√∫ltipla heran√ßa (n√£o suportada em Java).
- Quando a flexibilidade da composi√ß√£o √© mais importante que a estrutura fixa.
- Para algoritmos que mudam frequentemente sua estrutura.

---

### Conclus√£o

O **Template Method Pattern** √© uma solu√ß√£o elegante para algoritmos que compartilham uma estrutura comum, mas precisam de implementa√ß√µes espec√≠ficas em certas etapas. Ele promove reutiliza√ß√£o de c√≥digo, mant√©m consist√™ncia na execu√ß√£o e facilita a manuten√ß√£o.

Este padr√£o √© especialmente √∫til em Java para frameworks e bibliotecas que precisam fornecer uma estrutura base enquanto permitem customiza√ß√£o espec√≠fica. Se voc√™ trabalha com processamento de dados, pipelines ou qualquer cen√°rio com fluxos estruturados, o Template Method Pattern √© uma ferramenta valiosa para manter seu c√≥digo organizado e extens√≠vel.

---

Gostou deste post? Continue acompanhando para mais conte√∫dos sobre padr√µes de design e desenvolvimento em **Java**!
---

**üîó Reposit√≥rio de Exemplos**

Aqui o link para nosso laborat√≥rio: [https://github.com/Nosbielc/nosbielc-dev-demos](https://github.com/Nosbielc/nosbielc-dev-demos)