---
title: "Iterator Pattern em Java: Navega√ß√£o Sequencial atrav√©s de Cole√ß√µes"
description: "Aprenda como implementar o Iterator Pattern em Java para percorrer elementos de uma cole√ß√£o de forma sequencial sem expor sua representa√ß√£o interna. Descubra como este padr√£o comportamental pode simplificar o acesso a estruturas de dados complexas."
date: Jul 10 2025
---

## Introdu√ß√£o

O **Iterator Pattern** (Padr√£o Iterador) √© um padr√£o de design comportamental que fornece uma maneira de acessar elementos de uma cole√ß√£o sequencialmente sem expor sua representa√ß√£o subjacente. Este padr√£o √© fundamental na programa√ß√£o orientada a objetos e est√° amplamente implementado nas APIs de Java, sendo a base para o loop "for-each" e as Collections do Java.

Neste post, exploraremos o conceito do Iterator Pattern, suas vantagens e como implement√°-lo em Java com exemplos pr√°ticos de cole√ß√µes customizadas, demonstrando tanto implementa√ß√µes personalizadas quanto o uso das interfaces padr√£o do Java.

---

## O que √© o Iterator Pattern?

O Iterator Pattern resolve o problema de como percorrer elementos de uma cole√ß√£o agregada (lista, √°rvore, etc.) de forma uniforme, independentemente da estrutura interna dos dados. Em vez de expor os detalhes internos da cole√ß√£o, o padr√£o encapsula a l√≥gica de itera√ß√£o em um objeto separado.

**Principais componentes:**

1. **Iterator:** Interface que define m√©todos para percorrer elementos (`hasNext()`, `next()`, `remove()`).
2. **ConcreteIterator:** Implementa√ß√£o espec√≠fica do iterador para uma cole√ß√£o particular.
3. **Aggregate (Iterable):** Interface que define um m√©todo para criar um iterador.
4. **ConcreteAggregate:** Implementa√ß√£o espec√≠fica de uma cole√ß√£o que pode criar iteradores.

---

## Quando usar o Iterator Pattern?

- Quando voc√™ precisa acessar elementos de uma cole√ß√£o sem expor sua representa√ß√£o interna.
- Para fornecer uma interface uniforme para percorrer diferentes tipos de estruturas de dados.
- Quando voc√™ quer suportar m√∫ltiplas formas de percorrer a mesma cole√ß√£o.
- Para implementar opera√ß√µes de percurso em estruturas de dados complexas.
- Quando voc√™ precisa de lazy loading ou processamento sob demanda de elementos.

---

## Exemplo Pr√°tico em Java

Vamos implementar uma biblioteca de m√∫sica onde podemos iterar atrav√©s de playlists de diferentes formas:

---

#### 1. Definindo a Classe M√∫sica

Primeiro, vamos criar uma classe simples para representar uma m√∫sica:

```java
public class Musica {
    private String titulo;
    private String artista;
    private int duracao; // em segundos
    
    public Musica(String titulo, String artista, int duracao) {
        this.titulo = titulo;
        this.artista = artista;
        this.duracao = duracao;
    }
    
    public String getTitulo() {
        return titulo;
    }
    
    public String getArtista() {
        return artista;
    }
    
    public int getDuracao() {
        return duracao;
    }
    
    @Override
    public String toString() {
        return titulo + " - " + artista + " (" + formatarDuracao() + ")";
    }
    
    private String formatarDuracao() {
        int minutos = duracao / 60;
        int segundos = duracao % 60;
        return String.format("%d:%02d", minutos, segundos);
    }
}
```

#### 2. Implementando a Interface Iterator

Vamos criar uma interface personalizada para nosso iterador:

```java
public interface MusicaIterator {
    boolean hasNext();
    Musica next();
    void remove();
}
```

#### 3. Criando Iteradores Concretos

Implementaremos diferentes tipos de iteradores para diferentes formas de percorrer a playlist:

```java
import java.util.ArrayList;
import java.util.List;
import java.util.NoSuchElementException;

// Iterador sequencial normal
public class SequentialMusicIterator implements MusicaIterator {
    private List<Musica> musicas;
    private int posicao = 0;
    
    public SequentialMusicIterator(List<Musica> musicas) {
        this.musicas = new ArrayList<>(musicas);
    }
    
    @Override
    public boolean hasNext() {
        return posicao < musicas.size();
    }
    
    @Override
    public Musica next() {
        if (!hasNext()) {
            throw new NoSuchElementException("N√£o h√° mais m√∫sicas na playlist");
        }
        return musicas.get(posicao++);
    }
    
    @Override
    public void remove() {
        if (posicao == 0) {
            throw new IllegalStateException("next() deve ser chamado antes de remove()");
        }
        musicas.remove(--posicao);
    }
}

// Iterador embaralhado
public class ShuffledMusicIterator implements MusicaIterator {
    private List<Musica> musicas;
    private int posicao = 0;
    
    public ShuffledMusicIterator(List<Musica> musicas) {
        this.musicas = new ArrayList<>(musicas);
        embaralhar();
    }
    
    private void embaralhar() {
        for (int i = musicas.size() - 1; i > 0; i--) {
            int j = (int) (Math.random() * (i + 1));
            Musica temp = musicas.get(i);
            musicas.set(i, musicas.get(j));
            musicas.set(j, temp);
        }
    }
    
    @Override
    public boolean hasNext() {
        return posicao < musicas.size();
    }
    
    @Override
    public Musica next() {
        if (!hasNext()) {
            throw new NoSuchElementException("N√£o h√° mais m√∫sicas na playlist");
        }
        return musicas.get(posicao++);
    }
    
    @Override
    public void remove() {
        if (posicao == 0) {
            throw new IllegalStateException("next() deve ser chamado antes de remove()");
        }
        musicas.remove(--posicao);
    }
}

// Iterador por g√™nero (filtra apenas m√∫sicas de um artista espec√≠fico)
public class ArtistFilterIterator implements MusicaIterator {
    private List<Musica> musicas;
    private String artistaFiltro;
    private int posicao = 0;
    
    public ArtistFilterIterator(List<Musica> musicas, String artistaFiltro) {
        this.musicas = musicas;
        this.artistaFiltro = artistaFiltro;
        moverParaProximaValida();
    }
    
    @Override
    public boolean hasNext() {
        return posicao < musicas.size();
    }
    
    @Override
    public Musica next() {
        if (!hasNext()) {
            throw new NoSuchElementException("N√£o h√° mais m√∫sicas do artista: " + artistaFiltro);
        }
        
        Musica musica = musicas.get(posicao++);
        moverParaProximaValida();
        return musica;
    }
    
    @Override
    public void remove() {
        throw new UnsupportedOperationException("Remo√ß√£o n√£o suportada neste iterador");
    }
    
    private void moverParaProximaValida() {
        while (posicao < musicas.size() && 
               !musicas.get(posicao).getArtista().equalsIgnoreCase(artistaFiltro)) {
            posicao++;
        }
    }
}
```

#### 4. Implementando a Cole√ß√£o Agregada

Agora vamos criar nossa playlist que pode fornecer diferentes tipos de iteradores:

```java
import java.util.ArrayList;
import java.util.List;

public class Playlist {
    private String nome;
    private List<Musica> musicas;
    
    public Playlist(String nome) {
        this.nome = nome;
        this.musicas = new ArrayList<>();
    }
    
    public void adicionarMusica(Musica musica) {
        musicas.add(musica);
    }
    
    public void removerMusica(Musica musica) {
        musicas.remove(musica);
    }
    
    public String getNome() {
        return nome;
    }
    
    public int getTamanho() {
        return musicas.size();
    }
    
    // M√©todo para obter iterador sequencial
    public MusicaIterator createSequentialIterator() {
        return new SequentialMusicIterator(musicas);
    }
    
    // M√©todo para obter iterador embaralhado
    public MusicaIterator createShuffledIterator() {
        return new ShuffledMusicIterator(musicas);
    }
    
    // M√©todo para obter iterador filtrado por artista
    public MusicaIterator createArtistIterator(String artista) {
        return new ArtistFilterIterator(musicas, artista);
    }
    
    public int getDuracaoTotal() {
        return musicas.stream().mapToInt(Musica::getDuracao).sum();
    }
}
```

#### 5. Implementando Compatibilidade com Java Collections

Para integrar com o ecosistema Java, tamb√©m podemos implementar as interfaces padr√£o:

```java
import java.util.Iterator;

public class PlaylistIterable implements Iterable<Musica> {
    private Playlist playlist;
    
    public PlaylistIterable(Playlist playlist) {
        this.playlist = playlist;
    }
    
    @Override
    public Iterator<Musica> iterator() {
        return new Iterator<Musica>() {
            private MusicaIterator musicaIterator = playlist.createSequentialIterator();
            
            @Override
            public boolean hasNext() {
                return musicaIterator.hasNext();
            }
            
            @Override
            public Musica next() {
                return musicaIterator.next();
            }
            
            @Override
            public void remove() {
                musicaIterator.remove();
            }
        };
    }
}
```

#### 6. Exemplo de Uso

Vamos demonstrar como usar nossa implementa√ß√£o do Iterator Pattern:

```java
public class MusicPlayerDemo {
    public static void main(String[] args) {
        // Criando uma playlist
        Playlist minhaPlaylist = new Playlist("Minha Playlist Favorita");
        
        // Adicionando m√∫sicas
        minhaPlaylist.adicionarMusica(new Musica("Bohemian Rhapsody", "Queen", 355));
        minhaPlaylist.adicionarMusica(new Musica("Stairway to Heaven", "Led Zeppelin", 482));
        minhaPlaylist.adicionarMusica(new Musica("Another One Bites the Dust", "Queen", 215));
        minhaPlaylist.adicionarMusica(new Musica("Hotel California", "Eagles", 391));
        minhaPlaylist.adicionarMusica(new Musica("We Will Rock You", "Queen", 122));
        
        System.out.println("=== REPRODU√á√ÉO SEQUENCIAL ===");
        MusicaIterator sequentialIter = minhaPlaylist.createSequentialIterator();
        while (sequentialIter.hasNext()) {
            System.out.println("üéµ " + sequentialIter.next());
        }
        
        System.out.println("\n=== REPRODU√á√ÉO EMBARALHADA ===");
        MusicaIterator shuffledIter = minhaPlaylist.createShuffledIterator();
        while (shuffledIter.hasNext()) {
            System.out.println("üîÄ " + shuffledIter.next());
        }
        
        System.out.println("\n=== M√öSICAS DO QUEEN ===");
        MusicaIterator queenIter = minhaPlaylist.createArtistIterator("Queen");
        while (queenIter.hasNext()) {
            System.out.println("üëë " + queenIter.next());
        }
        
        // Usando com for-each (Java Collections)
        System.out.println("\n=== USANDO FOR-EACH ===");
        PlaylistIterable iterablePlaylist = new PlaylistIterable(minhaPlaylist);
        for (Musica musica : iterablePlaylist) {
            System.out.println("üéº " + musica);
        }
        
        // Demonstrando remo√ß√£o
        System.out.println("\n=== REMOVENDO M√öSICAS CURTAS ===");
        MusicaIterator removeIter = minhaPlaylist.createSequentialIterator();
        while (removeIter.hasNext()) {
            Musica musica = removeIter.next();
            if (musica.getDuracao() < 200) {
                System.out.println("Removendo: " + musica);
                removeIter.remove();
            }
        }
        
        System.out.println("M√∫sicas restantes: " + minhaPlaylist.getTamanho());
    }
}
```

### Sa√≠da do Programa

```
=== REPRODU√á√ÉO SEQUENCIAL ===
üéµ Bohemian Rhapsody - Queen (5:55)
üéµ Stairway to Heaven - Led Zeppelin (8:02)
üéµ Another One Bites the Dust - Queen (3:35)
üéµ Hotel California - Eagles (6:31)
üéµ We Will Rock You - Queen (2:02)

=== REPRODU√á√ÉO EMBARALHADA ===
üîÄ Hotel California - Eagles (6:31)
üîÄ We Will Rock You - Queen (2:02)
üîÄ Bohemian Rhapsody - Queen (5:55)
üîÄ Another One Bites the Dust - Queen (3:35)
üîÄ Stairway to Heaven - Led Zeppelin (8:02)

=== M√öSICAS DO QUEEN ===
üëë Bohemian Rhapsody - Queen (5:55)
üëë Another One Bites the Dust - Queen (3:35)
üëë We Will Rock You - Queen (2:02)

=== USANDO FOR-EACH ===
üéº Bohemian Rhapsody - Queen (5:55)
üéº Stairway to Heaven - Led Zeppelin (8:02)
üéº Another One Bites the Dust - Queen (3:35)
üéº Hotel California - Eagles (6:31)
üéº We Will Rock You - Queen (2:02)

=== REMOVENDO M√öSICAS CURTAS ===
Removendo: We Will Rock You - Queen (2:02)
M√∫sicas restantes: 4
```

### Explica√ß√£o do C√≥digo

1. **Separa√ß√£o de Responsabilidades:** A l√≥gica de itera√ß√£o √© separada da estrutura de dados da playlist.

2. **M√∫ltiplos Algoritmos:** Podemos percorrer a mesma cole√ß√£o de diferentes formas (sequencial, embaralhado, filtrado).

3. **Encapsulamento:** Os detalhes internos da implementa√ß√£o da playlist permanecem ocultos.

4. **Compatibilidade:** Nossa implementa√ß√£o funciona tanto com iteradores customizados quanto com o framework padr√£o do Java.

---

## Iterator Pattern nas Collections do Java

O Java implementa extensivamente o Iterator Pattern em suas Collections:

```java
import java.util.*;

public class JavaIteratorExample {
    public static void main(String[] args) {
        List<String> lista = Arrays.asList("Java", "Python", "JavaScript", "C++");
        
        // Iterator tradicional
        Iterator<String> iter = lista.iterator();
        while (iter.hasNext()) {
            System.out.println(iter.next());
        }
        
        // ListIterator (para listas)
        ListIterator<String> listIter = ((ArrayList<String>) new ArrayList<>(lista)).listIterator();
        
        // Percorrer para frente
        System.out.println("Para frente:");
        while (listIter.hasNext()) {
            System.out.println(listIter.next());
        }
        
        // Percorrer para tr√°s
        System.out.println("Para tr√°s:");
        while (listIter.hasPrevious()) {
            System.out.println(listIter.previous());
        }
        
        // Enhanced for loop (usa Iterator internamente)
        for (String linguagem : lista) {
            System.out.println(linguagem);
        }
        
        // Stream API (implementa conceitos do Iterator Pattern)
        lista.stream()
             .filter(lang -> lang.startsWith("J"))
             .forEach(System.out::println);
    }
}
```

---

## Vantagens e Desvantagens

### Vantagens

- **Acesso Uniforme:** Fornece uma interface consistente para percorrer diferentes tipos de cole√ß√µes.
- **Encapsulamento:** Mant√©m os detalhes internos da cole√ß√£o ocultos do cliente.
- **M√∫ltiplos Iteradores:** Permite m√∫ltiplas formas de percorrer a mesma cole√ß√£o.
- **Lazy Loading:** Permite processamento sob demanda dos elementos.
- **Separa√ß√£o de Responsabilidades:** A l√≥gica de itera√ß√£o √© separada da estrutura de dados.

### Desvantagens

- **Overhead de Mem√≥ria:** Cada iterador mant√©m seu pr√≥prio estado.
- **Complexidade:** Pode adicionar complexidade desnecess√°ria para cole√ß√µes simples.
- **Sincroniza√ß√£o:** Em ambientes multi-thread, pode ser necess√°rio sincronizar iteradores.
- **Estado Mut√°vel:** Modifica√ß√µes na cole√ß√£o durante itera√ß√£o podem causar problemas.

---

## Quando evitar o Iterator Pattern?

- Para cole√ß√µes muito simples onde acesso direto por √≠ndice √© suficiente.
- Quando o desempenho √© cr√≠tico e o overhead do iterador √© significativo.
- Em estruturas de dados que mudam frequentemente durante a itera√ß√£o.
- Para opera√ß√µes que requerem acesso aleat√≥rio aos elementos.
- Quando voc√™ n√£o precisa de m√∫ltiplas formas de percorrer os dados.

---

## Padr√µes Relacionados

- **Composite:** Iteradores s√£o frequentemente usados para percorrer estruturas compostas.
- **Factory Method:** Para criar diferentes tipos de iteradores.
- **Visitor:** Ambos processam elementos de uma cole√ß√£o, mas Visitor foca em opera√ß√µes espec√≠ficas.
- **Command:** Para encapsular opera√ß√µes de itera√ß√£o como comandos execut√°veis.

---

## Conclus√£o

O **Iterator Pattern** √© um dos padr√µes mais fundamentais e amplamente utilizados na programa√ß√£o orientada a objetos, especialmente em Java. Ele fornece uma maneira elegante de percorrer elementos de uma cole√ß√£o sem expor sua estrutura interna, promovendo encapsulamento e flexibilidade.

Este padr√£o √© essencial para qualquer desenvolvedor Java, pois est√° na base de quase todas as opera√ß√µes de cole√ß√£o na linguagem. Desde o loop "for-each" at√© a Stream API, o Iterator Pattern est√° presente em todo o ecossistema Java, facilitando o desenvolvimento de c√≥digo limpo, reutiliz√°vel e maint√≠vel.

Compreender e dominar o Iterator Pattern n√£o apenas melhora sua capacidade de trabalhar com as Collections do Java, mas tamb√©m o capacita a criar suas pr√≥prias estruturas de dados iter√°veis e flex√≠veis.

---

Gostou deste post? Continue acompanhando para mais conte√∫dos sobre padr√µes de design e desenvolvimento em **Java**!